<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python网络编程——TCP - Ctwo&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ctwo&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ctwo&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="2020&amp;#x2F;10&amp;#x2F;20 更新问题: UDP 和 TCP 可以绑定在同一个端口吗?  网络是令人捉摸不透的。我们想要传输的数据包有时会被丢弃，有时会被复制，有时顺序会被弄乱。如果仅使用 UDP 提供的数据协议，那么应用程序的代码还需要处理数据传输的可靠性，并提供传输发生错误时的恢复方案。但如果使用 TCP，数据包就被隐藏到协议层之下，应用程序只需要向目标机器发送流数据，TCP 会将丢失的信息重传。"><meta property="og:type" content="blog"><meta property="og:title" content="Python网络编程——TCP"><meta property="og:url" content="http://cyx0706.github.io/2020/10/20/python-web-3/"><meta property="og:site_name" content="Ctwo&#039;s Blog"><meta property="og:description" content="2020&amp;#x2F;10&amp;#x2F;20 更新问题: UDP 和 TCP 可以绑定在同一个端口吗?  网络是令人捉摸不透的。我们想要传输的数据包有时会被丢弃，有时会被复制，有时顺序会被弄乱。如果仅使用 UDP 提供的数据协议，那么应用程序的代码还需要处理数据传输的可靠性，并提供传输发生错误时的恢复方案。但如果使用 TCP，数据包就被隐藏到协议层之下，应用程序只需要向目标机器发送流数据，TCP 会将丢失的信息重传。"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://cyx0706.github.io/gallery/thumbnails/Internet.jpg"><meta property="article:published_time" content="2020-10-20T02:30:05.000Z"><meta property="article:modified_time" content="2020-10-25T01:42:54.302Z"><meta property="article:author" content="Ctwo"><meta property="article:tag" content="Internet Programming"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/thumbnails/Internet.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://cyx0706.github.io/2020/10/20/python-web-3/"},"headline":"Ctwo's Blog","image":["http://cyx0706.github.io/gallery/thumbnails/Internet.jpg"],"datePublished":"2020-10-20T02:30:05.000Z","dateModified":"2020-10-25T01:42:54.302Z","author":{"@type":"Person","name":"Ctwo"},"description":"2020&#x2F;10&#x2F;20 更新问题: UDP 和 TCP 可以绑定在同一个端口吗?  网络是令人捉摸不透的。我们想要传输的数据包有时会被丢弃，有时会被复制，有时顺序会被弄乱。如果仅使用 UDP 提供的数据协议，那么应用程序的代码还需要处理数据传输的可靠性，并提供传输发生错误时的恢复方案。但如果使用 TCP，数据包就被隐藏到协议层之下，应用程序只需要向目标机器发送流数据，TCP 会将丢失的信息重传。"}</script><link rel="canonical" href="http://cyx0706.github.io/2020/10/20/python-web-3/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://at.alicdn.com/t/font_1216726_izwtvafdd5o.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/railscasts.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/thumbnails/Internet.jpg" alt="Python网络编程——TCP"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2020-10-20T02:30:05.000Z" title="2020-10-20T02:30:05.000Z">2020-10-20</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-10-25T01:42:54.302Z" title="2020-10-25T01:42:54.302Z">2020-10-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Python网络编程——TCP</h1><div class="content"><ul>
<li><strong>2020/10/20 更新问题: UDP 和 TCP 可以绑定在同一个端口吗?</strong></li>
</ul>
<p>网络是令人捉摸不透的。我们想要传输的数据包有时会被丢弃，有时会被复制，有时顺序会被弄乱。如果仅使用 UDP 提供的数据协议，那么应用程序的代码还需要处理数据传输的可靠性，并提供传输发生错误时的恢复方案。但如果使用 TCP，数据包就被隐藏到协议层之下，应用程序只需要向目标机器发送流数据，TCP 会将丢失的信息重传。</p>
<a id="more"></a>
<h1>TCP</h1>
<h2 id="工作原理">工作原理</h2>
<p>TCP 是如何提供可靠连接的呢? 下面是它的基本工作原理</p>
<ul>
<li>每个 TCP 数据包都会有一个序列号，接收方通过该序列号讲响应数据包正确排序，也可以通过该序列号发现传输过程中丢失的数据包，并请求重传。</li>
<li>TCP 并不使用顺序的整数作为序号，而是通过一个计数器来记录发送的字节数，例如，如果一个包含1024字节的数据包序列号为7200，那么下一个数据包的序列号就是8224。这意味着，繁忙的网络栈无需记录其是如何将数据流分割为包的，当需要进行重传的时候，可以使用另一种分割方式将数据流分割为多个新数据包，而接收方仍然可以正常的接受数据包。</li>
<li>在一个优秀的 TCP 实现中，初始序列号是随机选择的，一定程度上降低被攻破的风险。</li>
<li>TCP 不通过锁步的方式进行通信，如果使用这种方式，就必须等待每个数据包都被确认接受后才能发送下一个数据包，速度非常的慢。相反，TCP 无需等待响应就能一口气发送多个数据包。在某一时刻发送方希望同时传输的数据量叫做 TCP 窗口的大小</li>
<li>接受方的 TCP 实现可以通过控制发送方的窗口大小来减缓或暂停连接。这叫做<strong>流量控制(Flow Control)</strong>，这使得接受方在输入缓冲区已满的时候可以禁止更多的数据包的传输。此时如果还有数据到达，将会被舍弃。</li>
</ul>
<p>TCP 的标准 POSIX 接口（可移植操作系统接口）分为被动监听套接字和主动连接套接字</p>
<ul>
<li><strong>被动套接字（passive socket）<strong>又叫做</strong>监听套接字（listening socket）</strong>，它维护了&quot;套接字名&quot;——IP地址和端口号。服务器通过该套接字来接受连接请求。但是套接字不能用于发送或接受任何数据，也不表示任何实际的网络会话，而是由服务器指示被动套接字通知操作系统优先使用哪个特定的 TCP 端口号来接受连接请求。</li>
<li><strong>主动套接字（active socket）<strong>又叫做</strong>连接套接字（connected socket）</strong>，他将一个特定的IP地址以及端口号与某个正在进行远程会话的主机绑定。连接套接字只用于与该特定远程主机进行通信。可以通过该套接字发送或接收数据，可以将 TCP 的连接套接字传给另一个接受普通文件作为输入的程序，该程序可能永远也不会知道它正在进行网络通信。</li>
</ul>
<p>被动套接字有接口 IP 地址和正在监听的端口号来唯一表示，即任何程序都无法再使用。而多个主动套接字是可以共享同一个本地套接字名的。例如有1000个客户端与一台繁忙的网络服务器都在进行 HTTP 连接。就会有1000个主动套接字都绑定到了服务器的公共 IP 地址和 TCP 的80端口，唯一表示主动套接字是如下的四元组: <code>(local_ip, local_port, remote_ip, remote_port)</code></p>
<p>操作系统是通过这个四元组来为主动 TCP 连接命名的，接到数据包是，操作系统会检查源地址和目标地址是否与系统中某一个主动套接字相符。</p>
<p>一个简单的 TCP 客户端和服务端的例子：</p>
<figure class="highlight python"><figcaption><span>tcp_sixteen.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse, socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recv_all</span>(<span class="params">sock, length</span>):</span></span><br><span class="line">    data = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(data) &lt; length:</span><br><span class="line">        more = sock.recv(length - <span class="built_in">len</span>(data))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> more:</span><br><span class="line">            <span class="keyword">raise</span> IOError(<span class="string">&quot;was expecting %d bytes but only received %d bytes before the socket closed&quot;</span></span><br><span class="line">                          % (length, <span class="built_in">len</span>(data)))</span><br><span class="line"></span><br><span class="line">        data += more</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">interface, port</span>):</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((interface, port))</span><br><span class="line">    sock.listen(<span class="number">1</span>)  <span class="comment"># 1?</span></span><br><span class="line">    print(<span class="string">&quot;Listening at&quot;</span>, sock.getsockname())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sc, sockname = sock.accept()</span><br><span class="line">        print(<span class="string">&quot;We have accepted a connection from&quot;</span>, sockname)</span><br><span class="line">        print(<span class="string">&quot;socket name:&quot;</span>, sc.getsockname())</span><br><span class="line">        print(<span class="string">&quot;socket peer:&quot;</span>, sc.getpeername())</span><br><span class="line">        message = recv_all(sc, <span class="number">16</span>)</span><br><span class="line">        print(<span class="string">&quot;Incoming sixteen-octet message:&quot;</span>, <span class="built_in">repr</span>(message))</span><br><span class="line">        sc.sendall(<span class="string">b&quot;Farewell, client&quot;</span>)</span><br><span class="line">        sc.close()</span><br><span class="line">        print(<span class="string">&quot;Reply sent, socket closed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>(<span class="params">host, port</span>):</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.connect((host, port))</span><br><span class="line">    print(<span class="string">&quot;Client has been assigned socket name &quot;</span>, sock.getsockname())</span><br><span class="line">    sock.sendall(<span class="string">b&quot;Hi there, server&quot;</span>)</span><br><span class="line">    reply = recv_all(sock, <span class="number">16</span>)</span><br><span class="line">    print(<span class="string">&quot;The server said &quot;</span>, <span class="built_in">repr</span>(reply))</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    choices = &#123;<span class="string">&quot;client&quot;</span>: client, <span class="string">&quot;server&quot;</span>: server&#125;</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Send and receive over TCP&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;role&quot;</span>, choices=choices.keys(), <span class="built_in">help</span>=<span class="string">&quot;which role to take&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;host&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;interface the server listens at / host the client sends to&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-p&quot;</span>, metavar=<span class="string">&quot;PORT&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1060</span>, <span class="built_in">help</span>=<span class="string">&quot;TCP port (default 1060)&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    func = choices[args.role]</span><br><span class="line">    func(args.host, args.p)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>看上去和 UDP 客户端和服务器程序很像，但 TCP 的 connect() 调用与 UDP 不同，UDP 的 connect 调用只是对绑定套接字进行了配置，设置了后续的 send(), recv() 调用锁需要的默认的远程地址，不会导致任何错误。而例子中的 connect() 调用则是真实的网络操作，会在要通信的客户端和服务端进行3次握手，这意味这 connect() 有可能失败，比如说没有运行服务器时运行客户端:</p>
<blockquote>
<p>ConnectionRefusedError:<br>
[WinError 10061] 由于目标计算机积极拒绝，无法连接。</p>
</blockquote>
<p>TCP 把发送的数据简单的看做流，而流是没有开始和结束标志，TCP 会将这些流分为多个数据包。而与之相比，UDP 的意义很简单，要么是发送一个数据报，要么是接收一个数据报，每个数据报都是原子的。TCP 可能会在传输过程中把数据流分为多个大小不同的数据包，然后在接受器端将这些数据包逐步重组。调用 send() 和 recv() 对 TCP 流会有什么效果？</p>
<p>send() 发生时，操作系统的网络栈可能会碰到下述3种情况：</p>
<ul>
<li>要发送的数据被立即被网络栈接收，这时可能由于网卡正好空闲，可以用于立即发送数据，也可能因为系统还有空间，可以将数据复制到临时发送缓冲区，这样程序就能继续运行。这些情况下，send() 会立即返回，由于发送的是整个串，返回值是整个数据串的长度。</li>
<li>另一种可能性是，网卡很忙，该套接字的发送缓冲区已满，而系统也无法或不愿为其分配更多的空间，此时 send() 默认情况下会直接阻塞进程，暂停应用程序，直到本地网络栈能够接受并传输数据。</li>
<li>最后一种情况介于2者之间，发送缓冲区几乎满了，但尚有空间，因此想要发送的部分数据可以进入发送缓冲区的队列等待发送，但剩余的数据块则必须等待。这种情况下 send() 会立即返回从数据串开始处起已经发送被接收的字节数，剩余尚未处理。</li>
</ul>
<p>由于这个原因，有时会在网络程序的代码中看到如下方式的循环:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytes_sent = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> bytes_sent &lt; <span class="built_in">len</span>(message):</span><br><span class="line">    message_remaining = message[bytes_sent:]</span><br><span class="line">    bytes_sent += s.send(message_remaining)</span><br></pre></td></tr></table></figure>
<p>Python socket标准库实现了 sendall() 方法，比上述有更高的效率。另外它在循环中释放了全局解释锁，因此其他的 Python 线程在所有数据完成之前不会竞争资源。</p>
<p>而对于 recv()，由于收到的字节不定长，Python 并没有标准库方法，操作系统内部的 recv() 实现的逻辑和发送相似：</p>
<ul>
<li>如果没有任何数据，那么 recv() 会阻塞程序直到数据到达</li>
<li>如果缓冲区里只有 recv() 需要返回的部分数据，那么即使这并非全部内容，也会立即返回缓冲区中已有的数据</li>
<li>如果缓冲区内的数据已经完整就绪，那么 recv() 收到所需的全部数据</li>
</ul>
<h2 id="死锁">死锁</h2>
<p>典型的 TCP 栈使用了缓冲区，这样就可以在应用程序准备好读取数据前存放到的接收到的数据，也可以在网络硬件准备好发送数据包前存放的数据。这些缓冲区的大小是有限制的，系统一般不会想让程序使用未发送的网络数据将 RAM 填满。毕竟，如果另一方尚未准备好处理数据，那么增加系统资源用于更大的缓冲区是没有意义的。</p>
<p>下面这个TCP服务器和客户端可能会造成死锁:</p>
<figure class="highlight python"><figcaption><span>tcp_deadlock.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">host, port, bytecount</span>):</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sock.bind((host, port))</span><br><span class="line">    sock.listen(<span class="number">1</span>)  <span class="comment"># 1?</span></span><br><span class="line">    print(<span class="string">&quot;Listening at&quot;</span>, sock.getsockname())</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        sc, sockname = sock.accept()</span><br><span class="line">        print(<span class="string">&quot;Processing up to 1024 bytes at a time from &quot;</span>, sockname)</span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            output = data.decode(<span class="string">&quot;ascii&quot;</span>).upper().encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">            sc.sendall(output)  <span class="comment"># send it back uppercase</span></span><br><span class="line">            n += <span class="built_in">len</span>(data)</span><br><span class="line">            print(<span class="string">&quot;\r %d bytes processed so far&quot;</span> % (n, ), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">            sys.stdout.flush()</span><br><span class="line">        print()</span><br><span class="line">        sc.close()</span><br><span class="line">        print(<span class="string">&quot;Socket closed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span>(<span class="params">host, port, bytecount</span>):</span></span><br><span class="line">    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    bytecount = (bytecount + <span class="number">15</span>) // <span class="number">16</span> * <span class="number">16</span>  <span class="comment"># round up to a multiple of 16</span></span><br><span class="line">    message = <span class="string">b&#x27;capitalize this!&#x27;</span>  <span class="comment"># 16-bytes message to repeat over and over</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;Sending &quot;</span>, bytecount, <span class="string">&quot; bytes of data, in chunks of  16 bytes&quot;</span>)</span><br><span class="line">    sock.connect((host, port))</span><br><span class="line">    sent = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> sent &lt; bytecount:</span><br><span class="line">        sock.sendall(message)</span><br><span class="line">        sent += <span class="built_in">len</span>(message)  <span class="comment"># repeat the same content</span></span><br><span class="line">        print(<span class="string">&quot;\r %d bytes sent &quot;</span> % (sent, ), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line">    </span><br><span class="line">    print()</span><br><span class="line">    sock.shutdown(socket.SHUT_WR)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;Receiving all the data tje sends back&quot;</span>)</span><br><span class="line">    received = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data = sock.recv(<span class="number">42</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> received:</span><br><span class="line">            print(<span class="string">&quot;The first data received says &quot;</span>, <span class="built_in">repr</span>(data))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        received += <span class="built_in">len</span>(data)</span><br><span class="line">        print(<span class="string">&quot;\r %d bytes received&quot;</span> % (received, ), end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    print()</span><br><span class="line">    sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    choices = &#123;<span class="string">&quot;client&quot;</span>: client, <span class="string">&quot;server&quot;</span>: server&#125;</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&quot;Get deadlock over TCP&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;role&quot;</span>, choices=choices.keys(), <span class="built_in">help</span>=<span class="string">&quot;which role to take&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;host&quot;</span>, <span class="built_in">help</span>=<span class="string">&quot;interface the server listens at / host the client sends to&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;bytecount&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, nargs=<span class="string">&quot;?&quot;</span>, default=<span class="number">16</span>, </span><br><span class="line">                        <span class="built_in">help</span>=<span class="string">&quot;number of bytes for client to send (default=16)&quot;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;-p&quot;</span>, metavar=<span class="string">&quot;PORT&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">1060</span>, <span class="built_in">help</span>=<span class="string">&quot;TCP port (default 1060)&quot;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    func = choices[args.role]</span><br><span class="line">    func(args.host, args.p, args.bytecount)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(venv) D:\my_py36\Python-Web\tcp&gt;python tcp_deadlock.py client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">32</span></span><br><span class="line">Sending  <span class="number">32</span>  <span class="built_in">bytes</span> of data, <span class="keyword">in</span> chunks of  <span class="number">16</span> <span class="built_in">bytes</span></span><br><span class="line"> <span class="number">32</span> <span class="built_in">bytes</span> sent</span><br><span class="line">Receiving <span class="built_in">all</span> the data tje sends back</span><br><span class="line">The first data received says  <span class="string">b&#x27;CAPITALIZE THIS!CAPITALIZE THIS!&#x27;</span></span><br><span class="line"> <span class="number">32</span> <span class="built_in">bytes</span> received</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(venv) D:\my_py36\Python-Web\tcp&gt;python tcp_deadlock.py server <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">Listening at (<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">1060</span>)</span><br><span class="line">Processing up to <span class="number">1024</span> <span class="built_in">bytes</span> at a time <span class="keyword">from</span>  (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">63331</span>)</span><br><span class="line"> <span class="number">32</span> <span class="built_in">bytes</span> processed so far</span><br><span class="line">Socket closed</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行一下，达到了我们的预期。在任何情况下像这样处理输入每次只处理一个数据块对于服务器来说是一个明智的选择，通过分块处理程序并及时发回响应，服务器限制了其任意时刻需要保存在内存中的数据量。如果服务器这样设计，即使每个客户端发送的数据多达几兆字节，服务器也能在同一时刻处理数百个客户端，而且不会使内存或者其他硬件资源难堪重负。</p>
<p>但当我们尝试发送大到一定程度的数据量的时候:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(venv) D:\my_py36\Python-Web\tcp&gt;python tcp_deadlock.py client <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">1073741824</span></span><br><span class="line">Sending  <span class="number">1073741824</span>  <span class="built_in">bytes</span> of data, <span class="keyword">in</span> chunks of  <span class="number">16</span> <span class="built_in">bytes</span></span><br><span class="line"> <span class="number">5435120</span> <span class="built_in">bytes</span> sent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Processing up to <span class="number">1024</span> <span class="built_in">bytes</span> at a time <span class="keyword">from</span>  (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">63395</span>)</span><br><span class="line"> <span class="number">2750112</span> <span class="built_in">bytes</span> processed so far</span><br></pre></td></tr></table></figure>
<p>送到一定大小的时候，就卡死了，客户端要比服务端多发送一些数据。为什么会停止呢？，因为服务器的输出缓冲区和客户端的输入缓冲区都会被填满，然后 TCP 就会使用滑动窗口协议而来处理这种情况，套接字会停止发送更多的数据，因为即使发送这些数据都会丢失。</p>
<p>为什么会导致死锁呢？考虑一下每个数据块的传输过程中都发送了什么。客户端使用 sendall() 发送数据块，然后服务端使用 recv() 来接收，处理，接着转为大写，再次使用 sendall() 发回去。由于还有数据需要发送，客户端并没有运行任何 recv() 调用，因此越来越大的数据填满了操作系统的缓冲区，导致无法接收更多的数据。</p>
<p>怎么解决？首先客户端和服务端可以通过套接字选项将阻塞关闭，这样像 send() 和 recv() 这样的调用在得知还不能发送数据时就会返回。第二种方法，程序可以使用某种技术同时处理来自多个输入的数据，可以采用多线程或进程，也可以采用 select() 或 poll() 等系统调用，这样当程序在接收或者发送套接字繁忙的时候等待，当他们任意一个空闲时做出响应。</p>
<p>告诉我们了什么呢？</p>
<ul>
<li>UDP 是不会发生这种事情，因为 UDP 并没有实现流量控制，当传达的数据量超出接收端的处理能力时，UDP 就会直接丢弃这些数据，由应用程序来发现数据报的丢失。</li>
<li>网络连接的每一段 TCP 栈中都有缓冲区，这些缓冲区能够暂时保存数据，这样一来当数据包传到接收端时，即使接收端没有运行 recv() 调用，也不需要丢弃这些数据包。当然缓冲区的大小是有限的，当不断尝试写入的数据始终没有被接受或处理，次数就无法再写数据，直到数据被读取出来前，即缓冲区有空余空间后，写数据操作才可以继续进行。</li>
<li>没有采用锁的协议的可能涉及的危险情况之一，如果一个协议并没有严格要求服务器在客户端请求发送完成后才读取完整的请求，然后再返回完整的响应，那么就有可能发生上述的死锁情况。</li>
</ul>
<h2 id="半开连接">半开连接</h2>
<p>例子中在客户端套接字完成发生之后使用了 shutdown()，这解决了一个重要的问题。如果服务器在遇到文件结束符之前一直永远的读数据，那么客户端如果避免在套接字上进行完整的 close() 操作。客户端如果防止运行很多 recv() 来接收服务器的响应呢？解决方法就是将套接字&quot;半关&quot;，即在一个方向上永久关闭，但并不销毁，在这种情况下服务器不会再读任何数据，但仍能向客户端发送剩余的响应。<code>SHUT_WR</code> 表示不知道通信对方何的输出何时结束，表示调用方不再向套接字写数据。而通信对方也会不再读取任何数据并且认为遇到了文件结束符。</p>
<p>有时当需要创建单向的套接字，往往会先创建双向套接字然后当套接字连接后立马运行 shutdown() 来关闭不需要的连接方向，这样操作系统的缓冲区也不会被无意义的填充。立即运行 shutdown() 也能够为通信对方提供更加清晰的错误信息，这样对方也不会混淆，也不会尝试在不需要发送数据的方向上发，否则意外数据可能会将缓冲区填满，由于这些数据永远不会被读取，导致无法写入，导致死锁。</p>
<h2 id="UDP-和-TCP-可以绑定在同一个端口吗">UDP 和 TCP 可以绑定在同一个端口吗?</h2>
<p>可以的。</p>
<p>首先，一个 UDP 应用是可以在不同的 IP 上绑定同一个端口，如绑定在127.0.0.1:1060 和 本机的 IP 地址下的 1060 端口的。无论任何时候，IP 网络栈都不会把 UDP 端口看作是一个可以连接或者正在使用的单独实体。相反，IP 网络栈关注的是 UDP “套接字名”，这是由 IP 接口和 UDP 端口号组成的二元组。如果只是端口号冲突无伤大雅。需要留意的是，客户端发送数据只会被一个服务器接受，这个服务器就是你 UDP 客户端指定的那个。</p>
<p>而对于 TCP 连接需要由四元组来形成，即(src_ip, src_port, dst_ip, dst_port)，当连接请求来了之后，服务器调用 accept 函数生成了一个新的 socket 这个端口占用的仍是 80（假设这个应用监控着 80）这些新的 socket 本地的 ip 和 port 都相同，远程的不同。这就是它可以建立很多很多的连接的原因。</p>
<p>最后 UDP 和 TCP 都可以绑定在同一个端口。再想想端口的定义：端口是一种抽象的软件结构（包括一些数据结构和 I/O 缓冲区）。应用程序通过系统调用与某端口建立连接（binding）后，传输层传给该端口的数据都被相应进程所接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP协议的实现中，端口操作类似于一般的 I/O 操作，进程获取一个端口，相当于获取本地唯一的 I/O 文件，可以用一般的读写原语访问之。</p>
<p>而端口号类似于文件描述符，用于区别不同端口。由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块（操作系统提供的），因此各自的端口号也相互独立，如 TCP有一个255号端口，UDP 也可以有一个255号端口，二者并不冲突。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python网络编程——TCP</p><p><a href="http://cyx0706.github.io/2020/10/20/python-web-3/">http://cyx0706.github.io/2020/10/20/python-web-3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Ctwo</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2020-10-20</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2020-10-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Internet-Programming/">Internet Programming</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/10/24/deep-learning-intro/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">deep-learning-intro</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/18/python-web-6/"><span class="level-item">python-web-6</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "9d5cd375abf7a69c64d2aed93176b53b",
            repo: "cyx0706.github.io",
            owner: "cyx0706",
            clientID: "4d458c0d13a2c2157dbd",
            clientSecret: "99a8159ca4a12d236f888be149168b92808a4e29",
            admin: ["cyx0706"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1</span><span class="level-item">TCP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#工作原理"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">工作原理</span></span></a></li><li><a class="level is-mobile" href="#死锁"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">死锁</span></span></a></li><li><a class="level is-mobile" href="#半开连接"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">半开连接</span></span></a></li><li><a class="level is-mobile" href="#UDP-和-TCP-可以绑定在同一个端口吗"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">UDP 和 TCP 可以绑定在同一个端口吗?</span></span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Ctwo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>