<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python-class - Ctwo&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ctwo&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ctwo&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="2020&amp;#x2F;10&amp;#x2F;25更新 整合了内容 Python面向对象编程 ps：相对熟悉的知识就不仔细列出了 定义与实例  class定义一个对象 类的实例是以函数的形式调用类对象来创建的，__init__()为构造函数，__del__()为析构函数  作用域规则  Python类中没有作用域，这与C++，Java不同。而需要显示使用self的原因在于Python没有提供显示声明变量的方式（如：int x；"><meta property="og:type" content="blog"><meta property="og:title" content="Python-class"><meta property="og:url" content="http://cyx0706.github.io/2019/07/15/Python-class-1/"><meta property="og:site_name" content="Ctwo&#039;s Blog"><meta property="og:description" content="2020&amp;#x2F;10&amp;#x2F;25更新 整合了内容 Python面向对象编程 ps：相对熟悉的知识就不仔细列出了 定义与实例  class定义一个对象 类的实例是以函数的形式调用类对象来创建的，__init__()为构造函数，__del__()为析构函数  作用域规则  Python类中没有作用域，这与C++，Java不同。而需要显示使用self的原因在于Python没有提供显示声明变量的方式（如：int x；"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://cyx0706.github.io/gallery/thumbnails/py.jpg"><meta property="article:published_time" content="2019-07-15T07:58:46.000Z"><meta property="article:modified_time" content="2020-10-25T01:59:11.230Z"><meta property="article:author" content="Ctwo"><meta property="article:tag" content="basis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/thumbnails/py.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://cyx0706.github.io/2019/07/15/Python-class-1/"},"headline":"Ctwo's Blog","image":["http://cyx0706.github.io/gallery/thumbnails/py.jpg"],"datePublished":"2019-07-15T07:58:46.000Z","dateModified":"2020-10-25T01:59:11.230Z","author":{"@type":"Person","name":"Ctwo"},"description":"2020&#x2F;10&#x2F;25更新 整合了内容 Python面向对象编程 ps：相对熟悉的知识就不仔细列出了 定义与实例  class定义一个对象 类的实例是以函数的形式调用类对象来创建的，__init__()为构造函数，__del__()为析构函数  作用域规则  Python类中没有作用域，这与C++，Java不同。而需要显示使用self的原因在于Python没有提供显示声明变量的方式（如：int x；"}</script><link rel="canonical" href="http://cyx0706.github.io/2019/07/15/Python-class-1/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://at.alicdn.com/t/font_1216726_izwtvafdd5o.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/railscasts.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/thumbnails/py.jpg" alt="Python-class"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2019-07-15T07:58:46.000Z" title="2019-07-15T07:58:46.000Z">2019-07-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2020-10-25T01:59:11.230Z" title="2020-10-25T01:59:11.230Z">2020-10-25</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Python-class</h1><div class="content"><p><strong>2020/10/25更新 整合了内容</strong></p>
<h1>Python面向对象编程</h1>
<p>ps：相对熟悉的知识就不仔细列出了</p>
<h2 id="定义与实例">定义与实例</h2>
<ul>
<li>class定义一个对象</li>
<li>类的实例是以函数的形式调用类对象来创建的，__init__()为构造函数，__del__()为析构函数</li>
</ul>
<h2 id="作用域规则">作用域规则</h2>
<ul>
<li>Python类中没有作用域，这与C++，Java不同。而需要显示使用self的原因在于Python没有提供显示声明变量的方式（如：int x；），因此无法知道在方法中要赋值的变量是不是局部变量，或者是否要保存为实例属性，而显示self可以解决这一问题。</li>
</ul>
<h2 id="继承">继承</h2>
<ul>
<li>super(cls, instance)会返回一个特殊对象，该对象支持在基类上执行属性查找。你可以通过super获取基类，调用基类的函数。在Python3中，super中的参数可以不要。</li>
<li>多继承不要使用不要使用不要使用</li>
</ul>
<h2 id="多态动态绑定和鸭子类型">多态动态绑定和鸭子类型</h2>
<ul>
<li>动态绑定（在继承背景下使用，也成多态），obj.attr，首先搜索实例本身，然后是实例的类定义，然后是基类，查找会返回第一个匹配项</li>
<li>动态绑定在于其不受对象obj的类型影响，因此如果执行像obj.name这样的查找，对于所有拥有name属性的obj都适用。这种行为有时候被称作“鸭子类型”（duck typing），这个名称来源于一个谚语：“如果看起来，叫声像而且走起路来像鸭子，那么它就是鸭子”。</li>
</ul>
<a id="more"></a>
<h2 id="静态方法和类方法">静态方法和类方法</h2>
<ul>
<li><strong>静态方法</strong>是一种普通函数，只不过它们正好位于类定义的命名空间中，它不会对任何实例进行操作。要定义静态方法，使用@staticmethod装饰器，同时调用静态方法只需要类名作为前缀cls.<em>staticmethod</em></li>
<li><strong>类方法</strong>是类本身作为对象进行操作的方法。使用@classmethod装饰器定义，类作为第一个参数传递，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Times</span>():</span></span><br><span class="line">    factor = <span class="number">1</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mul</span>(<span class="params">cls, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> cls.factor * x</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoTimes</span>(<span class="params">Times</span>):</span></span><br><span class="line">    factor = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">x = TwoTimes.mul(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#结果为8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="特性">特性</h2>
<ul>
<li>通常，访问实例或类的属性时，返回的是存储的相关值。而特性（property）是一种特殊的属性，访问它时会计算它的值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, radius</span>):</span></span><br><span class="line">        self.radius = radius</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> math.pi * self.radius ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * math.pi * self.radius</span><br><span class="line"></span><br><span class="line">c = Circle(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c.area)</span><br><span class="line"><span class="built_in">print</span>(c.perimeter)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="comment">#78.53981633974483</span></span><br><span class="line"><span class="comment">#31.41592653589793</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们的area和perimeter并非是通过调用函数来计算所得（并没有调用area（）），而是通过radius计算所得，结果作为类的一个属性，但是该属性不能被赋值。</li>
<li>特性还可以截获操作权，以设置和删除属性</li>
<li>下面例子使用property(getf=None, setf=None, delf=None, doc=None)来定义特性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个可控属性值 x</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    self._x = <span class="literal">None</span></span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">getx</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="keyword">return</span> self._x</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setx</span>(<span class="params">self, value</span>):</span></span><br><span class="line">	    self._x = value</span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delx</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="keyword">del</span> self._x</span><br><span class="line">	 </span><br><span class="line">	x = <span class="built_in">property</span>(getx, setx, delx, <span class="string">&quot;I&#x27;m the &#x27;x&#x27; property.&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果 c 是 C 的实例化, c.x 将触发 getter,c.x = value 将触发 setter ， del c.x 触发 deleter。</li>
<li>如果给定 doc 参数，其将成为这个属性值的 docstring，否则 property 函数就会复制 fget 函数的 docstring（如果有的话）。<br>
下面例子是另一种写法（推荐），将 property 函数用作装饰器可以很方便的创建只读属性：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parrot</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    self._voltage = <span class="number">100000</span></span><br><span class="line">	 </span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voltage</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="string">&quot;&quot;&quot;Get the current voltage.&quot;&quot;&quot;</span></span><br><span class="line">	    <span class="keyword">return</span> self._voltage</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 上面的代码将voltage()方法转化成同名只读属性的getter方法（功能一样，只是名字不一样）。</span></span><br><span class="line"><span class="comment"># property的getter,setter和deleter方法同样可以用作装饰器：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">	    self._x = <span class="literal">None</span></span><br><span class="line">	 </span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span></span><br><span class="line">	    <span class="keyword">return</span> self._x</span><br><span class="line">	 </span><br><span class="line"><span class="meta">	@x.setter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self, value</span>):</span></span><br><span class="line">	    self._x = value</span><br><span class="line">	 </span><br><span class="line"><span class="meta">	@x.deleter</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span></span><br><span class="line">	    <span class="keyword">del</span> self._x</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<ul>
<li>这个代码和第一个例子完全相同，但要注意这些额外函数的名字和property下的一样。</li>
</ul>
<h2 id="描述符">描述符</h2>
<ul>
<li>使用特性后，对对象的访问将通过一系列的用户定义的get，set，delete控制。这种属性将通过<strong>描述符对象</strong>进一步泛化。描述符就是一个代表属性值的对象。通过实现一个或多个特殊的__get__(), __set__(), __delete__()方法，可以将描述符和属性访问机制挂钩，也可以自定义这些操作。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypedProperty</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, <span class="built_in">type</span>, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment">#self.name = name</span></span><br><span class="line">        self.name = <span class="string">&quot;_&quot;</span> + name</span><br><span class="line">        self.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">        self.default = default <span class="keyword">if</span> default <span class="keyword">else</span> <span class="built_in">type</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(instance, self.name, self.default)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self.<span class="built_in">type</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Must be a %s&quot;</span> % self.<span class="built_in">type</span>)</span><br><span class="line">        <span class="built_in">setattr</span>(instance, self.name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Can&#x27;t delete attribute&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span></span><br><span class="line">    name = TypedProperty(<span class="string">&quot;name&quot;</span>, <span class="built_in">str</span>)</span><br><span class="line">    num = TypedProperty(<span class="string">&quot;num&quot;</span>, <span class="built_in">int</span>, <span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">f = Foo() </span><br><span class="line">a = f.name <span class="comment"># 隐式调用Foo.name.__get__(f, Foo)</span></span><br><span class="line">f.name = <span class="string">&quot;cyx&quot;</span> <span class="comment"># 调用Foo.name.__set__(f, &quot;cyx&quot;)</span></span><br><span class="line"><span class="keyword">del</span> f.name <span class="comment"># 调用Foo.name.__delete__(f)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>个人的理解就是（以上例中的name），创建了一个实例，该实例通过getattr调用str类型的属性，通过调用str的setattr来设置属性。</li>
<li>描述符只能在类级别上进行实例化。不能通过在__init__()和其他方法中创建描述符对象来为每个对象创建描述符。持有描述符的类使用的属性名称比实例存储的属性名称有更高的优先级，描述符对象接受name时对其值略加修改（加了一个下划线），原因就在于此，为了让描述符在实例上存储值，描述符必须挑选一个与它本身所用名称不同的名称。（不懂2333）。</li>
</ul>
<h2 id="数据封装和私有属性">数据封装和私有属性</h2>
<ol>
<li>object # public</li>
<li>__object__ # special, python system use, user should not define like it</li>
<li>__object # private (name mangling？ during runtime)</li>
<li>_object # obey python coding convention, consider it as private<br>
核心风格：避免用下划线作为变量名的开始。</li>
</ol>
<ul>
<li>类中的所有已双下滑线开头的名称，无论属性还是方法，都会形成_Classname__xx形式的新名称，这样不会和基类的私有变量发生冲突</li>
<li>尽管这种方法似乎隐藏了数据，但没有严格的机制来实际阻止对类的“私有”属性的访问。特别是如果已知类的名称和相应的私有属性的名称，则可以使用变形后的名称来访问。通过重定义__dir__()方法，类可以降低这些属性的可见性，__dir__()方法提供了对象的dir()所返回的名称列表,如下：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span></span><br><span class="line">    __bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self.__bar)</span><br><span class="line"></span><br><span class="line">a = Foo()</span><br><span class="line">a.foo()</span><br><span class="line">a._Foo__bar = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(a._Foo__bar)</span><br><span class="line">a.foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="comment">#5</span></span><br><span class="line"><span class="comment">#5</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这就很神奇，明明我声明了私有变量，你在类外却可以访问，这显然破坏了私有性，不要使用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    __x = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">dir</span>(A))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dir</span>(A)[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(a.__dir__())</span><br></pre></td></tr></table></figure>
<p>我们对dir的返回结果切片，自定义了__dir__()的返回结果，这样我们就无法在类外知道类里究竟有无私有变量了（私有变量一般会放在最前面）</p>
<h2 id="对象内存管理">对象内存管理</h2>
<ul>
<li>我们定义类后得到的实际是一个可以创建新实例的工厂。</li>
</ul>
<h3 id="init-new">__init__&amp;__new__</h3>
<ul>
<li>实例的创建包括2个步骤，使用特殊方法__new__()创建新的实例，然后使用__init__()初始化</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = Circle.__new__(Circle, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">isinstance</span>(c, Circle):</span><br><span class="line">    Circle.__init__(c, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>类的__new__()方法很少通过用户代码定义。如果定义了它，它的原型</li>
</ul>
<blockquote>
<p>__new__(cls, *args, **kwargs)</p>
</blockquote>
<p>所以，__init__ 和 __new__ 最主要的区别在于：<br>
1.__init__ 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。<br>
2.__new__ 通常用于控制生成一个新实例的过程。它是类级别的方法。</p>
<ul>
<li>依照Python官方文档的说法，__new__方法主要是当你继承一些不可变的class时(比如int, str, tuple)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的metaclass(元类)。<br>
如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class UpperStr(str):</span><br><span class="line">    def __init__(self, string):</span><br><span class="line">        string &#x3D; string.upper()</span><br><span class="line"></span><br><span class="line">class UpperStrClass(str):</span><br><span class="line">    def __new__(cls, value):</span><br><span class="line">       return super().__new__(cls, value.upper())</span><br><span class="line"></span><br><span class="line">u1 &#x3D; UpperStr(&quot;hello&quot;)</span><br><span class="line">u2 &#x3D; UpperStrClass(&quot;hello&quot;)</span><br><span class="line">print(u1)</span><br><span class="line">print(u2)</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line"># hello</span><br><span class="line"># HELLO</span><br></pre></td></tr></table></figure>
<h3 id="对象管理">对象管理</h3>
<ul>
<li>创建实例后，实例将由引用计数来管理。如果引用计数到达0，实例立即被销毁。当销毁时，解释器会先找与对象相关的__del__()并调用。实际上，很少定义该方法。唯一的例外是在销毁对象时需要执行操作的（如关闭文件，关闭网络连接或释放其他系统资源）。即使在这样的情况下，依靠__del__()来完全关闭依然存在风险。更好的方案是定义一个方法，如close（），程序可以使用该方法显示执行关闭操作。</li>
<li>有时，程序使用del语言删除对象引用。如果这导致引用计数为0，则会调用__del__(),但del通常不会直接调用__del__()</li>
<li>尽管定义__del__()很少会破坏垃圾回收器，但在某些编程模式下可能会引起问题，如：“观察者模式”（Observer Pattern）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, balance</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.observers = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> ob <span class="keyword">in</span> self.observers:</span><br><span class="line">            ob.close()</span><br><span class="line">        <span class="keyword">del</span> self.observers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.add(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unregister</span>(<span class="params">self, observer</span>):</span></span><br><span class="line">        self.observers.remove(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> ob <span class="keyword">in</span> self.observers:</span><br><span class="line">            ob.update()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span>(<span class="params">self, amount</span>):</span></span><br><span class="line">        self.balance -= amount</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountObserver</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, theAccount</span>):</span></span><br><span class="line">        self.theAccount = theAccount</span><br><span class="line">        theAccount.register(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.theAccount.unregister(self)</span><br><span class="line">        <span class="keyword">del</span> self.theAccount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Balance is %0.2f&quot;</span> % self.theAccount.balance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Account no longer use!&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = Account(<span class="string">&quot;Dave&quot;</span>, <span class="number">1000</span>)</span><br><span class="line">a_ob = AccountObserver(a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>看起来似乎没啥毛病，这段代码中Account类允许一组AccountObserver对象监控。每个Account会有一组观察者，而每个观察者会保留对账户的引用。</p>
</li>
<li>
<p>每个类都定义了__del__()，尝试清除（如注销），但是，这会建立一个引用循环，在这个循环中，引用计数永远不会到0，也永远不会执行清除操作，不仅如此，垃圾回收机器（gc机制）甚至不会清除该类，导致内存永久泄露。</p>
</li>
<li>
<p>解决方案就是使用弱引用，用一种在不增加引用计数的情况下创建对象的引用方式。</p>
</li>
<li>
<p>修改后的代码：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountObserver</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, theAccount</span>):</span></span><br><span class="line">        self.accounRef = weakref.ref(theAccount)  <span class="comment">#创建弱引用</span></span><br><span class="line">        theAccount.register(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        acc = self.accounRef  <span class="comment"># 获取账户</span></span><br><span class="line">        <span class="keyword">if</span> acc:               <span class="comment"># 如果存在则注销</span></span><br><span class="line">            acc.unregister(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Balance is %0.2f&quot;</span> % self.accounRef.balance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Account no longer use!&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="slots">__slots__</h2>
<ul>
<li>通过定义特殊变量__slots__，类可以限制对合法实例属性名称的设置，如下:</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span>():</span></span><br><span class="line">    __slot__ = (<span class="string">&quot;name&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">    ····</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>定义__slot__时，可以将实例上分配的属性名称限制为指定名称，否则引发AttributeError异常。这可以阻止其他人向现有实例增加新属性，或者用户写出属性导致加入新的属性</li>
<li>但实际使用中，__slot__从未被当做一种安全特性来实现。它实际上是对内存和执行速度的一种性能优化。在会创建大量对象的程序中，__slot__的使用可以显著的减少内存占用和执行时间</li>
</ul>
<h2 id="对象表示和属性绑定">对象表示和属性绑定</h2>
<ul>
<li>从内部实现上看，实例是用字典实现的，可以使用__dict__()属性访问该字典，这个字典包含的数据对每个实例而言是唯一的。对对象属性的修改会反映在__dict__()中，而直接修改__dict__()也会影响对象的属性。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = Account(<span class="string">&quot;xkx&quot;</span>, <span class="number">1200</span>)</span><br><span class="line">&gt;&gt;&gt;a.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;balance&#x27;</span>: <span class="number">1200</span>, <span class="string">&#x27;name&#x27;</span>: <span class="string">&quot;xkx&quot;</span>&#125;</span><br><span class="line">&gt;&gt;&gt;a.description = <span class="string">&quot;nb&quot;</span> <span class="comment"># 会在__dict__()中添加</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>实例通过特殊属性__class__()链接回类。类本身也可以看做对字典的浅层包装。<br>
&gt;&gt;&gt;a.__class__<br>
&lt;class ‘__main__.Account’&gt;</p>
</li>
<li>
<p>特殊属性__base__()中将类链接到它们的基类，该属性是一个基类元组。这种底层结构是获取，设置，删除对象属性的所有操作的基础。</p>
</li>
<li>
<p>当使用obj.<em>name</em> = <em>value</em>时，就会调用特殊方法obj.__setattr__(“<em>name</em>”, <em>value</em>),删除时会调用__delattr__(“<em>name</em>”)，这种默认的行为是修改或删除obj的局部的__dict__()的值。</p>
</li>
<li>
<p>查找属性时，obj.<em>name</em>, 将调用__getattribute__(“<em>name</em>”)，会检查特性，局部__dict__，类字典，基类。如果该过程失败，则会调用类的__getattr__()方法（如果定义了）来查找，如果还是没有找到，就会抛出AttributeError异常。</p>
</li>
<li>
<p>一般类很少重新定义属性访问运算符，但在编写通用的包装器和现有对象代理时，会用的上。</p>
</li>
</ul>
<!--more-->
<h2 id="元类">元类</h2>
<ul>
<li>类对象的创建方式是由一种名为<strong>元类</strong>的特殊对象控制的，简而言之，元类就是知道如何去创建和管理类的对象。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span> <span class="keyword">pass</span></span><br><span class="line">···</span><br><span class="line">&gt;&gt;&gt;<span class="built_in">type</span>(Foo)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">type</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>
<ul>
<li>这个例子，控制Foo创建的就是名为type的类</li>
<li>当使用class来定义新类时，将会发生很多事情。首先，类主体将作为其自己的私有字典内的一系列语句来执行。语句的执行和正常代码的执行一样，只是增加了会对私有成员发生名字变形。最后，类的名称，基类列表，字典将传给元类的构造函数，创建响应的类对象。下面例子演示了这一过程：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class_name &#x3D; &quot;Foo&quot;</span><br><span class="line">class_parents &#x3D; (object, )</span><br><span class="line">class_body &#x3D; &quot;&quot;&quot;</span><br><span class="line">def __init__(self, x):</span><br><span class="line">    self.x &#x3D; x</span><br><span class="line">def blah(self):</span><br><span class="line">    print(&quot;Hello World&quot;)</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">class_dict &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">exec(class_body, globals(), class_dict) # 在局部字典中执行类主体</span><br><span class="line">Foo &#x3D; type(class_name, class_parents, class_dict) # 创建对象</span><br><span class="line"></span><br><span class="line"># 打印一下Foo会得到和class Foo一样的结果</span><br><span class="line"># &lt;class &#39;__main__.Foo&#39;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>最后一步调用元类，该元类可以自己定义，如class Foo（mateclass=type）</li>
<li>如果没有显示指定元类，将检查基类元组，元类与第一个基类的类型相同。</li>
<li>如果没有指定基类，class将检查全局变量__metaclass__是否存在。如果有，就会使用其创建类。</li>
<li>最最后，使用默认元类，Python3默认为type()</li>
<li>例子，要求用户定义类的方法必须拥有一个文档字符串：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DocMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, bases, <span class="built_in">dict</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">            <span class="keyword">if</span> key.startwith(<span class="string">&quot;__&quot;</span>): <span class="comment"># 跳过私有方法</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(value, <span class="string">&quot;__call__&quot;</span>): <span class="comment"># 跳过不可调用的方法</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">getattr</span>(value, <span class="string">&quot;__doc__&quot;</span>): <span class="comment"># 检查doc字符属性</span></span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">&quot;%s must have a docsting&quot;</span> % key)</span><br><span class="line">        <span class="built_in">type</span>.__init__(self, name, bases, <span class="built_in">dict</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>更高级的用法（看看就行了），元类可以在创建类前同时检查和更改类定义的内容，这需要重写__new__().</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypedProperty</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, <span class="built_in">type</span>, default=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.name = <span class="literal">None</span></span><br><span class="line">        self.<span class="built_in">type</span> = <span class="built_in">type</span></span><br><span class="line">        self.default = default <span class="keyword">if</span> default <span class="keyword">else</span> <span class="built_in">type</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, instance, owner</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getattr</span>(instance, self.name, self.default)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, instance, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self.<span class="built_in">type</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Must be a %s&quot;</span> % self.<span class="built_in">type</span>)</span><br><span class="line">        <span class="built_in">setattr</span>(instance, self.name, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span>(<span class="params">self, instance</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> AttributeError(<span class="string">&quot;Can&#x27;t delete attribute&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeMeta</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, name, bases, <span class="built_in">dict</span></span>):</span></span><br><span class="line">        slots = []</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, TypedProperty):</span><br><span class="line">                value.name = <span class="string">&quot;_&quot;</span> + key</span><br><span class="line">                slots.append(value.name)</span><br><span class="line">        <span class="built_in">dict</span>[<span class="string">&#x27;__slots__&#x27;</span>] = slots</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">type</span>.__new__(cls, name, bases, <span class="built_in">dict</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>part1的一个例子，不同的是我们设置self.name变成了在元类里设置。该例子中，元类扫描类字典，查找TypedProperty的实例，找到的话，设置name属性并在slots中建立名称列表。完成之后__slots__将添加到类字典中，通过type元类的__new__来构造。</li>
</ul>
<h2 id="类装饰器">类装饰器</h2>
<ul>
<li>有时不用小题大做弄元类来处理一些问题，只用简单的写个修饰器就行。如将类添加到注册表或数据库。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">cls</span>):</span></span><br><span class="line">    <span class="keyword">if</span> cls.classification == <span class="string">&quot;A&quot;</span>:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> cls.classification == <span class="string">&quot;B&quot;</span>:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># do something</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>():</span></span><br><span class="line">    classification = <span class="string">&quot;A&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>这个例子可以对类按自定义的功能划分，进行不同的后续处理（写不同的日志啥的）</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python-class</p><p><a href="http://cyx0706.github.io/2019/07/15/Python-class-1/">http://cyx0706.github.io/2019/07/15/Python-class-1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Ctwo</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2019-07-15</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2020-10-25</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/basis/">basis</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2019/07/19/AssemblyLanguageBasis-2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">汇编语言语法-2</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2019/07/12/AssemblyLanguageBasis-1/"><span class="level-item">汇编语言语法-1</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "d879d04be9c6da8a151a5c09593ba972",
            repo: "cyx0706.github.io",
            owner: "cyx0706",
            clientID: "4d458c0d13a2c2157dbd",
            clientSecret: "99a8159ca4a12d236f888be149168b92808a4e29",
            admin: ["cyx0706"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#"><span class="level-left"><span class="level-item">1</span><span class="level-item">Python面向对象编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义与实例"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">定义与实例</span></span></a></li><li><a class="level is-mobile" href="#作用域规则"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">作用域规则</span></span></a></li><li><a class="level is-mobile" href="#继承"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">继承</span></span></a></li><li><a class="level is-mobile" href="#多态动态绑定和鸭子类型"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">多态动态绑定和鸭子类型</span></span></a></li><li><a class="level is-mobile" href="#静态方法和类方法"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">静态方法和类方法</span></span></a></li><li><a class="level is-mobile" href="#特性"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">特性</span></span></a></li><li><a class="level is-mobile" href="#描述符"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">描述符</span></span></a></li><li><a class="level is-mobile" href="#数据封装和私有属性"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">数据封装和私有属性</span></span></a></li><li><a class="level is-mobile" href="#对象内存管理"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">对象内存管理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#init-new"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">__init__&amp;__new__</span></span></a></li><li><a class="level is-mobile" href="#对象管理"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">对象管理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#slots"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">__slots__</span></span></a></li><li><a class="level is-mobile" href="#对象表示和属性绑定"><span class="level-left"><span class="level-item">1.11</span><span class="level-item">对象表示和属性绑定</span></span></a></li><li><a class="level is-mobile" href="#元类"><span class="level-left"><span class="level-item">1.12</span><span class="level-item">元类</span></span></a></li><li><a class="level is-mobile" href="#类装饰器"><span class="level-left"><span class="level-item">1.13</span><span class="level-item">类装饰器</span></span></a></li></ul></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Ctwo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>