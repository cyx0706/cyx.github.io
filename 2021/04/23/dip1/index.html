<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>数字图像处理 - Ctwo&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Ctwo&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Ctwo&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="2021&amp;#x2F;4&amp;#x2F;24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了服务器渲染 空间&amp;amp;频率域滤波用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼） 空间域滤波直方图均衡化直方图的形状往往与图像的外观有关。  在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0） 亮的图像的直方图中，多数直方图容器集中在灰度级的高端 低对比度的图像的直方图中，直方图容"><meta property="og:type" content="blog"><meta property="og:title" content="数字图像处理"><meta property="og:url" content="http://cyx0706.github.io/2021/04/23/dip1/"><meta property="og:site_name" content="Ctwo&#039;s Blog"><meta property="og:description" content="2021&amp;#x2F;4&amp;#x2F;24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了服务器渲染 空间&amp;amp;频率域滤波用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼） 空间域滤波直方图均衡化直方图的形状往往与图像的外观有关。  在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0） 亮的图像的直方图中，多数直方图容器集中在灰度级的高端 低对比度的图像的直方图中，直方图容"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://cyx0706.github.io/gallery/cover/dip.jpg"><meta property="article:published_time" content="2021-04-23T01:43:40.000Z"><meta property="article:modified_time" content="2021-04-24T04:47:09.399Z"><meta property="article:author" content="Ctwo"><meta property="article:tag" content="CV"><meta property="article:tag" content="Digital Image Processing"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/gallery/cover/dip.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://cyx0706.github.io/2021/04/23/dip1/"},"headline":"数字图像处理","image":["http://cyx0706.github.io/gallery/cover/dip.jpg"],"datePublished":"2021-04-23T01:43:40.000Z","dateModified":"2021-04-24T04:47:09.399Z","author":{"@type":"Person","name":"Ctwo"},"publisher":{"@type":"Organization","name":"Ctwo's Blog","logo":{"@type":"ImageObject","url":"http://cyx0706.github.io/img/logo.svg"}},"description":"2021&#x2F;4&#x2F;24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了服务器渲染 空间&amp;频率域滤波用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼） 空间域滤波直方图均衡化直方图的形状往往与图像的外观有关。  在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0） 亮的图像的直方图中，多数直方图容器集中在灰度级的高端 低对比度的图像的直方图中，直方图容"}</script><link rel="canonical" href="http://cyx0706.github.io/2021/04/23/dip1/"><link rel="alternate" href="/atom.xml" title="Ctwo&#039;s Blog" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/5.13.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/railscasts.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/gallery/cover/dip.jpg" alt="数字图像处理"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-04-23T01:43:40.000Z" title="2021-04-23T01:43:40.000Z">2021-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-04-24T04:47:09.399Z" title="2021-04-24T04:47:09.399Z">2021-04-24</time></span><span class="level-item"><a class="link-muted" href="/categories/Digital-Image-Processing/">Digital Image Processing</a></span></div></div><h1 class="title is-3 is-size-4-mobile">数字图像处理</h1><div class="content"><p>2021/4/24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了<a target="_blank" rel="noopener" href="https://github.com/MakerGYT/markdown-it-latex2img">服务器渲染</a></p>
<h1 id="空间-amp-频率域滤波"><a href="#空间-amp-频率域滤波" class="headerlink" title="空间&amp;频率域滤波"></a>空间&amp;频率域滤波</h1><p>用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼）</p>
<h2 id="空间域滤波"><a href="#空间域滤波" class="headerlink" title="空间域滤波"></a>空间域滤波</h2><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图的形状往往与图像的外观有关。</p>
<ul>
<li>在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0）</li>
<li>亮的图像的直方图中，多数直方图容器集中在灰度级的高端</li>
<li>低对比度的图像的直方图中，直方图容器基本位于灰度级的中间</li>
<li>高对比度图像的直方图，容器覆盖了较宽的范围，并且像素的分布是基本均匀的<a id="more"></a>
直方图均衡化的数学原理我们暂且不提，假如我们把直方图每个部分出现频率和总统计量做除法，得到一个概率分布函数$p_r(r)$，均衡化变换就是将一个概率分布不规则，不均匀的$p_r(r)$变化为分布均匀的新的函数$p_s(s)$。</li>
</ul>
<p>Python 代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分不同的空间来绘图</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;./IMG_2546.JPG&quot;</span>).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图</span></span><br><span class="line">img_array = np.array(img)</span><br><span class="line">x_num, y_num = img.size</span><br><span class="line"><span class="comment"># 查看直方图</span></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.hist(img_array.flatten(), <span class="number">256</span>)  <span class="comment"># 变换成 1 维再绘制直方图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用直方图均衡再查看直方图</span></span><br><span class="line"><span class="comment"># 每个 bins 数组的区间值对应一个 im_hist 数组中的强度值</span></span><br><span class="line">im_hist, bins = np.histogram(img_array.flatten(), <span class="number">256</span>, density=<span class="literal">True</span>)  <span class="comment"># 转化为直方图</span></span><br><span class="line">cdf = im_hist.cumsum()  <span class="comment"># 计算累计分布函数 cumulative distribution function</span></span><br><span class="line"><span class="comment"># cdf(a)=P(x&lt;=a)</span></span><br><span class="line">cdf = <span class="number">255</span> * (cdf / cdf[-<span class="number">1</span>])  <span class="comment"># 归一化到 0-1 之后转化到 0-255</span></span><br><span class="line"><span class="comment"># interp(x, xp, yp)输入原函数的一系列点(xp, yp)使用线性插值方法模拟函数并计算 f(x)</span></span><br><span class="line"><span class="comment"># s = cdf(r)</span></span><br><span class="line">img_array_transformed = np.interp(img_array.flatten(), bins[:<span class="number">256</span>], cdf)</span><br><span class="line"><span class="comment"># 变换回原来的数组结构后转为图片</span></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.hist(img_array_transformed, <span class="number">256</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.savefig(<span class="string">&quot;exp.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>原直方图和均衡化后的图片的直方图：</p>
<p><img src="https://i.loli.net/2021/04/15/v5HmMwd6icXlhzS.png" alt="直方图均衡化.png"></p>
<p>原图和均衡化后的图的对比：</p>
<p><img src="https://i.loli.net/2021/04/15/A18ByaERU6ZMH5v.png" alt="原图.png"></p>
<p><img src="https://i.loli.net/2021/04/15/7lEKRXDQhBZ15SW.png" alt="均衡化后.png"></p>
<p>如果我们对局部直方图均衡化，还可以显示出全局直方图均衡化无法显示的灰度细节。</p>
<h3 id="低通空间滤波器"><a href="#低通空间滤波器" class="headerlink" title="低通空间滤波器"></a>低通空间滤波器</h3><ul>
<li>高斯核</li>
</ul>
<p><img src="https://i.loli.net/2021/04/15/lAeMogtphx1cRS8.png" alt="3x3高斯核"></p>
<p>有现成的库可以调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line">img = img.<span class="built_in">filter</span>(ImageFilter.GaussianBlur(radius=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p>
<h3 id="高通空间滤波器"><a href="#高通空间滤波器" class="headerlink" title="高通空间滤波器"></a>高通空间滤波器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sharpening_f</span>(<span class="params">img_array, kernel, c</span>):</span></span><br><span class="line">    <span class="comment"># 卷积锐化图像</span></span><br><span class="line"></span><br><span class="line">    new_array = signal.convolve2d(img_array, kernel,</span><br><span class="line">                                  boundary=<span class="string">&#x27;symm&#x27;</span>,</span><br><span class="line">                                  mode=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">    new_array[new_array &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    new_array[new_array &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    new_array = img_array + c*new_array</span><br><span class="line">    new_array[new_array &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    new_array[new_array &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> new_array</span><br></pre></td></tr></table></figure>
<ul>
<li>Sobel</li>
</ul>
<p>横方向的 Sobel 算子，用于提取出水平方向的边界：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 -1 & 0 & 1\\
 2 & 0 & 2\\
 -1 & 0 & 1
\end{bmatrix}</script><ul>
<li>拉普拉斯</li>
</ul>
<p>拉普拉斯是导数算子，因此会突出图像中急剧的灰度过渡，并不强调缓慢变化的灰度区域，这会使得原图像产生灰色边缘线和其他不连续的特征，因此将原图像与拉普拉斯变换后的图像相加就能够恢复背景特征，并且保留拉普拉斯锐化的效果。</p>
<p>一种拉普拉斯核如下：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 1 & 1 & 1\\
 1 & -8 & 1\\
 1 & 1 & 1
\end{bmatrix}</script><p>又或者是：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
 0 & 1 & 0\\
 1 & -4 & 1\\
 0 & 1 & 0
\end{bmatrix}</script><ul>
<li>钝化掩蔽</li>
</ul>
<p>分为三个步骤：</p>
<ol>
<li>模糊原图像</li>
<li>从原图中减去模糊后的图像（产生的差称为模板）</li>
<li>将模板与原图像相加</li>
</ol>
<p>令 $\bar{f}(x, y)$ 表示模糊后的图像，钝化掩蔽的过程可以用公式表示为：</p>
<script type="math/tex; mode=display">
\left\{\begin{matrix}
g_{mask}(x, y) = f(x, y) - \bar{f}(x, y)  \\ 
g(x, y) = f(x, y)+kg_{mask}(x, y)
\end{matrix}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;./IMG_2546.JPG&quot;</span>).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">origin_array = np.array(image)</span><br><span class="line">blurred_image = image.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">blurred_array = np.array(blurred_image)</span><br><span class="line">mask_array = origin_array - blurred_array</span><br><span class="line"></span><br><span class="line">weight_k = <span class="number">2</span></span><br><span class="line">new_array = origin_array + weight_k * mask_array</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">ax1.hist(origin_array.flatten(), <span class="number">256</span>)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">ax2.hist(new_array.flatten(), <span class="number">256</span>)</span><br><span class="line">ax2.set_title(<span class="string">&quot;shielding Sharpened&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;exp6_sharping2.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>原图像：<br><img src="https://i.loli.net/2021/04/24/fOHkQztd3SYwa8c.png" alt="原图"></p>
<p>增强后的图像：<br><img src="https://i.loli.net/2021/04/24/pXlqekVEhW4NJro.png" alt="钝化掩蔽后的图像"></p>
<p>可以看到，我们仅仅是把 k 设置为 2，就出现了边界线。当 $k = 1$ 称为钝化掩蔽，$k &gt; 1$ 时被称为高提升滤波，选择 $k &lt; 1$ 可以减少钝化模板的贡献。</p>
<h2 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h2><p>在深度学习出来前，频率域滤波一直是数字图像处理的比较热门的研究点（我们老师说的），频率域滤波的功能还是挺强大的，同样关于原理不过多介绍。</p>
<h3 id="FFT-amp-频谱"><a href="#FFT-amp-频谱" class="headerlink" title="FFT&amp;频谱"></a>FFT&amp;频谱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fft_transform</span>(<span class="params">in_path, name, out_path=<span class="string">&quot;.&quot;</span></span>):</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(in_path)</span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    <span class="comment"># 关闭坐标轴</span></span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Origin Image&quot;</span>)</span><br><span class="line">    image = image.convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.imshow(image, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Gray Image&quot;</span>)</span><br><span class="line">    <span class="comment"># 进行傅立叶变换，并显示结果</span></span><br><span class="line">    fft2 = np.fft.fft2(image)</span><br><span class="line">    <span class="comment"># 取 log</span></span><br><span class="line">    log_fft2 = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(fft2))</span><br><span class="line">    <span class="comment"># 将图像变换的原点移动到频域矩形的中心，并显示效果</span></span><br><span class="line">    shift2center = np.fft.fftshift(fft2)</span><br><span class="line">    <span class="comment"># 对中心化后的结果进行对数变换</span></span><br><span class="line">    log_shift2center = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(shift2center))</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.imshow(np.absolute(shift2center), <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;shift2center&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.imshow(log_shift2center, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;log_shift2center&quot;</span>)</span><br><span class="line">    plt.savefig(os.path.join(out_path, (<span class="string">&quot;fft_transformed_&quot;</span> + name)))</span><br><span class="line">    <span class="comment"># clear all figure</span></span><br><span class="line">    plt.clf()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/24/Ley6mGWhobpKzBi.png" alt="fft_transformed.png"></p>
<p>需要注意的是要对变换后的图像取 log，不然值太大会无法在正常的灰度级下显示。</p>
<h3 id="高低通滤波器"><a href="#高低通滤波器" class="headerlink" title="高低通滤波器"></a>高低通滤波器</h3><p>课本上介绍的 3 个高通滤波器：</p>
<ul>
<li>理想高通滤波器<script type="math/tex; mode=display">
H(u,v)=\left\{\begin{matrix}
0, & D(u,v)\le D_0\\
1, & D(u,v)\gt D_0
\end{matrix}\right.</script></li>
<li>高斯高通滤波器<script type="math/tex; mode=display">
H(u,v)=1-e^{-D^2(u,v)/2D_0^2}</script></li>
<li>巴德沃斯高通滤波器<script type="math/tex; mode=display">
H(u,v)=\frac{1}{1+\left [ D_0/D(u,v) \right ]^{2n}}</script></li>
</ul>
<p>其中 $D_0$ 表示截止频率到矩阵中心的距离，$D(u,v)$ 表示频率矩阵中心到矩阵中任意一点的距离。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">pa, pb</span>):</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">    dis = sqrt((pa[<span class="number">0</span>] - pb[<span class="number">0</span>]) ** <span class="number">2</span> + (pa[<span class="number">1</span>] - pb[<span class="number">1</span>]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_filter</span>(<span class="params">cls, d, shape, *args, **kwargs</span>):</span></span><br><span class="line">        transfer_matrix = np.zeros(shape)</span><br><span class="line">        center_point = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x - <span class="number">1</span>) // <span class="number">2</span>, shape))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">1</span>]):</span><br><span class="line">                dist = cal_distance(center_point, (i, j))</span><br><span class="line">                transfer_matrix[i, j] = cls.get_one(d, dist, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> transfer_matrix</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILPFLowPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dist &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILPFHighPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dist &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaussianHighPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - np.exp(-(dist ** <span class="number">2</span>) / (<span class="number">2</span> * (d ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaussianLowPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.exp(-(dist ** <span class="number">2</span>) / (<span class="number">2</span> * (d ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterworthFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        n = kwargs[<span class="string">&quot;n&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / ((<span class="number">1</span> + dist / d) ** (<span class="number">2</span> * n))</span><br></pre></td></tr></table></figure>
<p>使用滤波器进行滤波：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">choice = <span class="string">&quot;material/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(choice).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line"></span><br><span class="line">sq = <span class="built_in">min</span>(img.size[<span class="number">0</span>], img.size[<span class="number">1</span>])</span><br><span class="line">img = img.resize((sq, sq))</span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line">f_shift = np.fft.fftshift(f)</span><br><span class="line"><span class="comment"># gauss_filter_matrix = GaussianLowPassFilter.generate_filter(50, img.size)</span></span><br><span class="line">butter_filter_matrix = ButterworthFilter.generate_filter(<span class="number">30</span>, img.size, n=<span class="number">2</span>)</span><br><span class="line">filter_matrix = np.fft.ifftshift(f_shift*butter_filter_matrix)</span><br><span class="line">transform_img = np.<span class="built_in">abs</span>(np.fft.ifft2(filter_matrix))</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(transform_img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;gauss_filter.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h1 id="扩展：人脸磨皮算法"><a href="#扩展：人脸磨皮算法" class="headerlink" title="扩展：人脸磨皮算法"></a>扩展：人脸磨皮算法</h1><h2 id="Bilateral"><a href="#Bilateral" class="headerlink" title="Bilateral"></a>Bilateral</h2><p>双边滤波（Bilateral filter）结合图像的空间邻近度和像素值相似度，同时考虑空域信息和灰度相似性，达到保边去噪的目的。</p>
<p>它的滤波器核由两个函数生成：空间域核和值域核。</p>
<p>空间域核是由像素位置欧式距离决定的模板权值，公式：</p>
<script type="math/tex; mode=display">
w_d(i,j,k,l)=exp(-\frac{(i-k)^2+(i-l)^2}{2\delta_d^2})</script><p>其中i,j 代表的是当前坐标点的位置 k，l 为中心坐标点，$\delta_d$ 代表高斯函数的标准差。很明显 $w_d$ 是计算临近点 ij 到中心点的临近程度，因此空间域核是用于衡量空间临近的程度。这代表空间域的高斯函数。</p>
<p>值域核是由灰度像素值的差值决定模板的权值的：</p>
<script type="math/tex; mode=display">
w_r(i,j,k,l)=exp(-\frac{(f(i,j)-f(k,l))^2}{2\delta_r^2})</script><p>$f(i,j)$代表每个点的灰度像素值，$f(k,l)$代表中点的像素值，$\delta_r$也是值域核下高斯函数的标准差。将两者相乘就能得到双边滤波的模板权值：</p>
<script type="math/tex; mode=display">
w(i,j,k,l)=w_d(i,j,k,l)*w_r(i,j,k,l)
=exp(-\frac{(i-k)^2+(i-l)^2}{2\delta_d^2}-\frac{(f(i,j)-f(k,l))^2}{2\delta_r^2})</script><p>化简：</p>
<script type="math/tex; mode=display">
g(i,j)=\frac{\sum_{kl}f(k,l)w(i,j,k,l)}{\sum_{kl}w(i,j,k,l)}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公式看起来实现起来好麻烦，还好有库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">file_name = <span class="string">&#x27;./material/4.jpg&#x27;</span></span><br><span class="line">image = cv2.imread(file_name)</span><br><span class="line"></span><br><span class="line">dst = cv2.bilateralFilter(src=image, d=<span class="number">0</span>, sigmaColor=<span class="number">100</span>, sigmaSpace=<span class="number">15</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Source&quot;</span>, image)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Filter&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/04/21/dm7hzjEcTlV2Qqu.png" alt="bilateral.png"></p>
<h2 id="表面模糊"><a href="#表面模糊" class="headerlink" title="表面模糊"></a>表面模糊</h2><p>图像的表面模糊处理，其作用是在保留图像边缘的情况下，对图像的表面进行模糊处理。在对人物皮肤处理上，比高斯模糊更有效。（高斯模糊在使人物皮肤光洁的同时，也将一些边缘特征给模糊了）</p>
<p>在处理手法上，表面模糊也与前面提到的卷积处理手段不同，表面模糊是每一个像素点都有自己的卷积矩阵，而且还是 3 套，用以对应于像素的 R、G、B 分量。</p>
<p>表面模糊有 2 个参数，即模糊半径 r 和模糊阈值 T，模糊半径确定模糊的范围，而模糊范围确定的是卷积矩阵的大小，模糊矩阵是一个长宽相等的矩阵，长度 $l=2r+1$。</p>
<p>矩阵的中间元素是当前的像素点，其余的元素按照下面的方法计算：</p>
<script type="math/tex; mode=display">
w_{ij}=1-\frac{\left | I_{ij}-I_0 \right | }{2.5T}</script><p>$I_{ij}$ 是图像值，$I_0$是模板矩阵中心的图像值</p>
<p>一般来说，会有预处理： $w_{ij}=max(0, w_{ij})$</p>
<p>根据卷积运算，每个像素通过表面模糊之后的值为：</p>
<script type="math/tex; mode=display">
w_{ij}=\frac{\sum w_{ij}I_{ij}}{\sum w_{ij}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表面模糊算法</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sur_blur</span>(<span class="params">origin, threshold, r</span>):</span></span><br><span class="line">    transformed = origin * <span class="number">1.0</span></span><br><span class="line">    row, col = origin.shape</span><br><span class="line">    w_size = r * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, row - <span class="number">1</span> - r):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(r, col - <span class="number">1</span> - r):</span><br><span class="line">            iij = origin[i-r: i+r+<span class="number">1</span>, j-r: j+r+<span class="number">1</span>]</span><br><span class="line">            i0 = numpy.ones([w_size, w_size]) * origin[i, j]</span><br><span class="line">            wij = <span class="number">1</span> - <span class="built_in">abs</span>(iij - i0) / (<span class="number">2.5</span> * threshold)</span><br><span class="line">            wij[wij &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            tmp = iij * wij</span><br><span class="line">            transformed[i, j] = tmp.<span class="built_in">sum</span>() / wij.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> transformed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./material/4.jpg&#x27;</span></span><br><span class="line">img = io.imread(file_name)</span><br><span class="line">img_out = img * <span class="number">1.0</span></span><br><span class="line">boundary = <span class="number">20</span></span><br><span class="line">half_size = <span class="number">10</span></span><br><span class="line">img_out[:, :, <span class="number">0</span>] = sur_blur(img[:, :, <span class="number">0</span>], boundary, half_size)</span><br><span class="line">img_out[:, :, <span class="number">1</span>] = sur_blur(img[:, :, <span class="number">1</span>], boundary, half_size)</span><br><span class="line">img_out[:, :, <span class="number">2</span>] = sur_blur(img[:, :, <span class="number">2</span>], boundary, half_size)</span><br><span class="line"></span><br><span class="line">img_out = img_out / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(img_out)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;surface_blur.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>效果挺好，就是算的有点慢：<br><img src="https://i.loli.net/2021/04/24/6W2wB7e5Jriu9Kb.png" alt="surface_blur.png"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li>数字图像处理（第四版），冈萨雷斯</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/118496347">高斯滤波和双边滤波原理和python实现</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/zb1165048017/article/details/107798789">一个简单好用的磨皮祛斑算法理论和python实现</a></li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>数字图像处理</p><p><a href="http://cyx0706.github.io/2021/04/23/dip1/">http://cyx0706.github.io/2021/04/23/dip1/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Ctwo</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-04-23</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2021-04-24</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/CV/">CV</a><a class="link-muted mr-2" rel="tag" href="/tags/Digital-Image-Processing/">Digital Image Processing</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/08/dip2/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">数字图像处理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/19/winter-2021/"><span class="level-item">winter-2021</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "3d592a77df7d29d7e5aded5b7ea8d6c2",
            repo: "cyx0706.github.io",
            owner: "cyx0706",
            clientID: "4d458c0d13a2c2157dbd",
            clientSecret: "99a8159ca4a12d236f888be149168b92808a4e29",
            admin: ["cyx0706"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#空间-amp-频率域滤波"><span class="level-left"><span class="level-item">1</span><span class="level-item">空间&amp;频率域滤波</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#空间域滤波"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">空间域滤波</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#直方图均衡化"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">直方图均衡化</span></span></a></li><li><a class="level is-mobile" href="#低通空间滤波器"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">低通空间滤波器</span></span></a></li><li><a class="level is-mobile" href="#高通空间滤波器"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">高通空间滤波器</span></span></a></li></ul></li><li><a class="level is-mobile" href="#频率域滤波"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">频率域滤波</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#FFT-amp-频谱"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">FFT&amp;频谱</span></span></a></li><li><a class="level is-mobile" href="#高低通滤波器"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">高低通滤波器</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#扩展：人脸磨皮算法"><span class="level-left"><span class="level-item">2</span><span class="level-item">扩展：人脸磨皮算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Bilateral"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Bilateral</span></span></a></li><li><a class="level is-mobile" href="#表面模糊"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">表面模糊</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考链接"><span class="level-left"><span class="level-item">3</span><span class="level-item">参考链接</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Ctwo&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Ctwo</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>