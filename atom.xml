<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ctwo&#39;s Blog</title>
  <icon>http://cyx0706.github.io/icon.png</icon>
  
  <link href="http://cyx0706.github.io/atom.xml" rel="self"/>
  
  <link href="http://cyx0706.github.io/"/>
  <updated>2021-07-09T09:57:04.074Z</updated>
  <id>http://cyx0706.github.io/</id>
  
  <author>
    <name>Ctwo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>中兴捧月竞赛</title>
    <link href="http://cyx0706.github.io/2021/07/07/zte-contest/"/>
    <id>http://cyx0706.github.io/2021/07/07/zte-contest/</id>
    <published>2021-07-07T09:43:47.000Z</published>
    <updated>2021-07-09T09:57:04.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一届中兴捧月大赛"><a href="#第十一届中兴捧月大赛" class="headerlink" title="第十一届中兴捧月大赛"></a>第十一届中兴捧月大赛</h1><p>菜菜子，比特派，美羊大学，江湖名号 Ctwo</p><p>不太可以具体透露题目，只能随便讲讲了。<del>不会有人是来看题解的吧</del><br><a id="more"></a></p><h2 id="初赛"><a href="#初赛" class="headerlink" title="初赛"></a>初赛</h2><p>那时候正想着有啥算法比赛可以参加的，刚好看见宣传，直接冲了。</p><p>比特派初赛是 ACM 赛制，时间有点久了，记不清具体的题目了，两场任意一场晋级就行，第一场题目简单，第二场我印象深，我 Python dp 做一道题，疯狂超时，结束了下来拿 C++ 写了一手，过了，我当场裂开。</p><ul><li>C++ 真就是王道呗</li></ul><h2 id="复赛"><a href="#复赛" class="headerlink" title="复赛"></a>复赛</h2><p>比特派是新的赛道，整个赛制还不太成型吧，别的赛道有打榜的，有测评姬评分评时的，复赛就是答辩，我们直接来两个新题。</p><p>第一题扑克，规则贼像同花顺，就差没写上去了，根据规则对输入的组比较大小。</p><ul><li>不难，一看就是一个考察设计的题目，好说，我那点为数不多的设计模式的知识有用武之地了！然后就憋了一下午啥也没写出来，左想不好，右想扩展性不好。最后顶不住了，就直接类抽象+规则反射加载来写了，感觉设计的还不错？新规则直接加就好了，牌和规则分离了。可惜的是本来还想着把花色大小比较之类的也抽出来，但没设计好，所以，<strong>解耦合了，但没有完全解开</strong>，菜死了。</li></ul><p>第二题 50x50x50x50 种情况下求最优解，我贪心试了比暴力还慢，人傻了，怎么办呢，剪枝吧，咋剪？我写了个奇奇怪怪的方法，调了个奇奇怪怪的参数，哎，好用！虽然方法不行，但写报告我可铆足了劲，各种数学公式，符号化描述，看起来有严谨的数学方法那味了，仔细一推敲啥都不是</p><p><img src="https://i.loli.net/2021/07/07/swcQiNqXFRn9teB.png" alt=""></p><p>答辩就讲讲思路，值的说的是我上午在想不会需要自我介绍吧，准备了一手刚好用上了。</p><h2 id="决赛"><a href="#决赛" class="headerlink" title="决赛"></a>决赛</h2><blockquote><p>吃，码，睡，快乐陪跑 3 天，坐标西安中兴和泰酒店</p></blockquote><p>很早就想参加一次这种全国的线下决赛了，老是馋 <strong>AiDai</strong> 的经历。</p><p>一去发现好多研究生大佬，我一个算法菜鸡瑟瑟发抖。认识了初赛两场全 AC 的大佬（忘加微信了，有幸拍到大佬肩膀和大佬共进餐）</p><p>决赛收获还是颇多的，虽然只拿到了一个 cherry 键盘（京东卖 398 元），但重在过程对吧，学到了就不亏。</p><h3 id="赛"><a href="#赛" class="headerlink" title="赛"></a>赛</h3><p>先说题目，因为没啥说的，依旧是复杂情况的优化问题，没有约束条件的时候很容易，但在约束条件下变成了 NP 问题，还是关于图的，并且数据有多组，奇奇怪怪的方法就不好使了，咋办，我情急之下想到了模拟退火，整个 2 天就围着它转了。</p><p>改改参数，换个初始化，加升温，动态调整概率，动态调整循环次数……</p><p>结果还可以，但比大佬们还是有差距的，海，最后一天听了思路，我可以自豪的说<strong>我当初设想过，我和第一的方法60%是一样的！</strong>，当然这 40% 就是人家比我强的关键了。</p><p>不同组的题目不一样，也听了别的组的第一名的报告，感觉自己还需要努力。</p><h3 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h3><blockquote><p>算法优化不好总不能难为自己，吃饭还是要好好吃的</p></blockquote><ul><li><p>吃夜宵：吃不完<br><img src="https://i.loli.net/2021/07/07/vWKEY4IrFxU3kHm.jpg" alt=""></p></li><li><p>吃自助：营养均衡</p></li></ul><p><img src="https://i.loli.net/2021/07/07/CSQ4MqwBW5VLaHD.jpg"  /></p><p><img src="https://i.loli.net/2021/07/07/aqoBCLtdXyuO4hs.jpg" alt=""></p><p>回学校后我大呼廉价自选的西兰花难吃，我同学都说我口味都变刁钻了。</p><ul><li>吃甜点：重拳出击</li></ul><p><img src="https://i.loli.net/2021/07/07/hGyAb9qVugZnxBT.jpg" alt=""></p><p>要不是不好意思，我能把那边的一盘都吃完。</p><h3 id="睡"><a href="#睡" class="headerlink" title="睡"></a>睡</h3><blockquote><p>11 点半就睡了，早上 6 点多醒，绝对把没写完的代码拖到明天，程序员听了都说养生。</p></blockquote><p>5 星级酒店，房间大，浴室大，每天晚上都能洗热水澡</p><p>房间的隔音效果很好，设施也全，中午也可睡大椅子，想想在学校艰苦的生活就不禁觉得，<strong>要有钱</strong>。</p><p>可惜没照照片，放张百度的：</p><p><img src="https://i.loli.net/2021/07/07/xelgyipUsoq24wM.png" alt=""></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>开赛的时候阴差阳错捞了个公仔，说不定就是把我运气用完调不出来参的罪魁祸首。</p><p><img src="https://i.loli.net/2021/07/07/3NOdnT2hWqtcMYi.jpg" alt=""></p><h3 id="归程"><a href="#归程" class="headerlink" title="归程"></a>归程</h3><blockquote><p>人在青岛，刚下飞机</p></blockquote><p>由于考试原因提前离开，真佩服自己心大到考试周来，然后信息论就考的。。一般。。没想象中的好，还是复习差点火候。</p><p>等飞机的时候还看着数据库呢，隔着过道坐的小情侣都笑了。</p><h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><ul><li>感谢复赛点醒我的好哥们戴老师，决赛和我一个房间的龚同学</li><li>感谢负责人文姐比赛的时候对我的照顾</li><li>感谢掌门人们耐心的听完我的方法</li><li>图源：<a href="https://www.nowcoder.com/activity/challenge2021/index">比赛官网</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;第十一届中兴捧月大赛&quot;&gt;&lt;a href=&quot;#第十一届中兴捧月大赛&quot; class=&quot;headerlink&quot; title=&quot;第十一届中兴捧月大赛&quot;&gt;&lt;/a&gt;第十一届中兴捧月大赛&lt;/h1&gt;&lt;p&gt;菜菜子，比特派，美羊大学，江湖名号 Ctwo&lt;/p&gt;
&lt;p&gt;不太可以具体透露题目，只能随便讲讲了。&lt;del&gt;不会有人是来看题解的吧&lt;/del&gt;&lt;br&gt;</summary>
    
    
    
    <category term="travel" scheme="http://cyx0706.github.io/categories/travel/"/>
    
    
    <category term="travel" scheme="http://cyx0706.github.io/tags/travel/"/>
    
  </entry>
  
  <entry>
    <title>我免费了，暂时的</title>
    <link href="http://cyx0706.github.io/2021/07/07/tempfree/"/>
    <id>http://cyx0706.github.io/2021/07/07/tempfree/</id>
    <published>2021-07-07T07:55:14.000Z</published>
    <updated>2021-07-09T11:21:47.143Z</updated>
    
    <content type="html"><![CDATA[<p><del>上篇写的太负能量了吧</del></p><p>夏令营的面经不想写，也没啥写的，我就没几个夏令营 =_=</p><p>看到一个很好的基于 icarus 的样式，试了一下，有点问题，有空解决了再换上吧。<br><a id="more"></a></p><h1 id="学期总结和暑假计划"><a href="#学期总结和暑假计划" class="headerlink" title="学期总结和暑假计划"></a>学期总结和暑假计划</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大三的最后一个学期，前半学期没啥紧张感，甚至打了好几个下午的星际，现在想想就离谱，早点准备点东西不好吗。</p><p>后半学期直接 907, 9 点起床，0 点多睡觉。一周干 7 天，先是处理完了校团委的项目，又是社团的一些烦心事，然后数字图像处理大作业，再是导师考核题目，最后期末前一周跑出去打中兴的比赛，感觉做的事情还不少，要是每个学期都这样就好了。</p><p>中兴的比赛会在 zte 那篇里面说，我大学第一次线下比赛，挺开心。数字图像处理大项目也是我在实验室的做的项目，花了很多的时间而没有一个好的效果，现在想想当时没有放弃就很好了，坚持着做到了最后面。成功虽然不让我满意，也不让我的面试官们满意，但我和享受这整个过程。</p><p>数字图像处理这门课我超级喜欢，老师也很好，是我这学期为数不多的认真学习的课程了。</p><p>数据库考的血炸（成绩说不定又要滑了），老惭愧了，毕竟是爱特程序部也是一届站长的。</p><h2 id="假期规划"><a href="#假期规划" class="headerlink" title="假期规划"></a>假期规划</h2><p>依稀记得寒假计划完成的不多，这次要继续努力了（能早返校我效率直接翻一倍！）</p><p>撇开夏令营来计划：</p><ul><li>翻新博客！</li><li>数字图像处理笔记整理成博客</li><li>重学线性代数，概率统计，找一个好的教程/课程，尽可能的站在计算机的角度去理解学习这两门</li><li>复习专业课知识，准备夏令营</li><li>英语！英语！英语！口语！口语！口语！背单词+磨耳朵</li><li>念念不忘的《一个64位操作系统的实现》，《程序员的自我修养》，有时间就再学学吧</li><li>C++，这个必须要点了，至少看完 primer plus 或者我那本很厚的书吧（当然是挑重要的看），有好的练手项目就做做</li><li>画画！锻炼！</li></ul><p>摸了，这个 todo-list 挺多的，具体到每一天要坚持列任务和计划，我最近总是列着列着就忘记了，还有用好 win 的日历，也可以加入计划和安排。</p><p>老规矩，假期结束来验收，有啥会在这里更新</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;上篇写的太负能量了吧&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;夏令营的面经不想写，也没啥写的，我就没几个夏令营 =_=&lt;/p&gt;
&lt;p&gt;看到一个很好的基于 icarus 的样式，试了一下，有点问题，有空解决了再换上吧。&lt;br&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>black</title>
    <link href="http://cyx0706.github.io/2021/07/05/black/"/>
    <id>http://cyx0706.github.io/2021/07/05/black/</id>
    <published>2021-07-05T14:26:31.000Z</published>
    <updated>2021-07-07T08:31:54.604Z</updated>
    
    <content type="html"><![CDATA[<p>将近半学期没怎么写博客了，最近夏令营频频心态爆炸，这两天刚考完试颓废过去了，感觉自己的心情也没有很好的调整上来。</p><a id="more"></a><p>又一学期结束了，似乎熬出头了？以后再也没有了考试</p><p>突然有一阵空虚感——我以后的课程还学啥呢，反正不是我想选的，又不在乎成绩了。</p><p>我为有一刹那这么想的自己感到羞愧，想想这一学期的工作，自己嘴边上挂着菜，成绩不好，没学上了，报名和准备夏令营的时候也没做到很好记录。</p><blockquote><p>人菜就需要在时间上磨平差距</p></blockquote><p>我信奉的就是这样简单粗暴的规则，大佬抬抬手就完成的，自己做不来那就多砸时间来完成。</p><p>那么在夏令营报名和准备上我和大佬的区别在于绩点和科研竞赛，那么我有做什么去尝试填吗。没有，报名草草完事，没有提前准备一些最基础的问题。</p><p>可是我在学期末这段时间忙于中兴捧月的比赛，数字图像处理的课程设计，导师考核这些事情，兼顾不过来也正常吧。</p><p>那为什么不早点完成了，前面做的那么悠闲结果事情堆积了，怪时间不够？</p><p>可是…可是…</p><p>自我的责备和批判并不能带给我什么实质性的东西，我缺少一个 “壮士一去不复返的” 精神，看着身边的保研边缘同学都拼了老命的学，考出了优秀的成绩，我不禁在想，为什么我做不到呢？</p><p>有时候总会觉得自己人格分裂了，另一半自己在拼命的否定，挑出各种缺点来鞭笞自己去努力改正。剩下的一半在拼命的鼓励自己，还有希望，还能再坚持，你是最棒的。</p><p>说实话，前一段时间海洋哥的事情，毕竟是我的同学，我也有了解，我和他一样，也是怀着和实力或者能力不相符的梦想，都试着努力让自己变得更加优秀。</p><p>谁让这是我自己做出的决定呢！</p><blockquote><p>明天不会更好，只会将一步步的错误积累下来</p></blockquote><p>你要时时刻刻保持优秀，保持努力，不然就会被抛下，我能做什么？咬牙坚持呗。</p><p>不管怎么说，我愿意在我相信的道路上前进。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;将近半学期没怎么写博客了，最近夏令营频频心态爆炸，这两天刚考完试颓废过去了，感觉自己的心情也没有很好的调整上来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://cyx0706.github.io/2021/05/26/dip3/"/>
    <id>http://cyx0706.github.io/2021/05/26/dip3/</id>
    <published>2021-05-26T13:16:50.000Z</published>
    <updated>2021-07-09T11:20:41.219Z</updated>
    
    <content type="html"><![CDATA[<ul><li>2021/5/28: 增加了部分示例代码</li></ul><h1 id="小波变换"><a href="#小波变换" class="headerlink" title="小波变换"></a>小波变换</h1><blockquote><p>小波 (Wavelet) 是时间（空间）频率的局部化分析，它通过伸缩平移运算对信号(函数)逐步进行多尺度细化，最终达到高频处时间细分，低频处频率细分，能自动适应时频信号分析的要求，从而可聚焦到信号的任意细节。有人把小波变换称为“数学显微镜”。</p></blockquote><p>而对于图像处理相关领域，小波变换曾经相当的热门，一些经典的算法如 JPEG-2000 就是基于小波变换原理的。</p><p>要理解小波变换，有一大堆需要铺垫的东西……</p><a id="more"></a><h2 id="多分辨率金字塔（Image-Resolution-Pyramids）"><a href="#多分辨率金字塔（Image-Resolution-Pyramids）" class="headerlink" title="多分辨率金字塔（Image Resolution Pyramids）"></a>多分辨率金字塔（Image Resolution Pyramids）</h2><p>一般情况下，我们要处理的都是一张具有固定分辨率的图片，但有些时候，我们会对同一图像的不同分辨率的子图像进行处理，这些子图像往往是根据原图下采样得到的，如果我们将最大的图像放在底部，最小的放在顶部，就能得到一个金字塔的形状。图片金字塔可以用于图像融合，不过这不是我们在这里需要关注的。</p><div style="display: table-cell"><img src="https://i.loli.net/2021/05/25/aZ1STdIOJhlDk6t.png" alt="image resolution pyramids"  style="text-align:center"/></div><p>下采样的方法有很多，比如<strong>高斯金字塔</strong>：顶部图像中每个像素等于下一层图像中5个像素的高斯加权平均值。这样我们将一个 $M \times N$ 的图像变成了 $\frac{M}{2}\times\frac{N}{2}$ 大小的图像。</p><p>我们可以通过一个大图，通过高斯金字塔生成的方法得到多个小分辨率的图，但是，当我们通过金字塔顶层的图片来试图复原原图的时候，我们复原后的图会很“糊”，因为我们在下采样的时候丢失了图片的一些细节。</p><p>有没有一种变换可以不丢失细节，我们通过金字塔的顶层和一些其他的东西也可以复原出来原图像？</p><p>我们先在一维研究一下这个问题，如下图：</p><p>我们想要通过一组变换将 $x(n)$ 变换 $x’(n)$ 然后再通过一个反变换得到 $\hat{x}(n)$，使得$x(n)=\hat{x}(n)$ ：</p><div style="display: table-cell"><img src="https://i.loli.net/2021/05/25/RvYzmUDK4JgH63b.png" alt="image resolution pyramids"  style="text-align:center"/></div><h2 id="子带编码（Subband-Coding）"><a href="#子带编码（Subband-Coding）" class="headerlink" title="子带编码（Subband Coding）"></a>子带编码（Subband Coding）</h2><p>子带编码一种以信号频谱为依据的编码方法，将信号分解成不同频带分量来去除信号相关性（可以理解成正交分解），再将分量分别进行取样、量化、编码，从而得到一组互不相关的码字合并在一起后进行传输。</p><p>如果我们可以把 $x(n)$ 按照高频和低频分解，在根据一种方法重组，根据子带编码的理论，我们可以无失真的重建 $x(n)$。</p><p><img src="https://i.loli.net/2021/05/25/8MBcUIANXFnwjP7.png" alt="子带编码"></p><p>现在，我们只需要找到一组 $\{ h_0(n),  h_1(n), g_0(n), g_1(n)\}$ 就可以无失真重建了，我们可以将这一组的函数看做是一组一维的滤波器。</p><h3 id="上-下采样（Upsampling-Downsampling）"><a href="#上-下采样（Upsampling-Downsampling）" class="headerlink" title="上/下采样（Upsampling/Downsampling）"></a>上/下采样（Upsampling/Downsampling）</h3><p>我们首先对 $x(n)$ 做 Z 变换：</p><script type="math/tex; mode=display">X(Z) = \sum_{-\infty}^{\infty}x(n)z^{-n}</script><p>在时间域我们做因数为 2 的下采样可以等价到在 Z 域（复频域）的计算：</p><script type="math/tex; mode=display">x_{down}(n)=x(2n) \Leftrightarrow X_{down}(Z)=\frac{1}{2}\left[X\left(z^{1 / 2}\right)+X\left(-z^{1 / 2}\right)\right]</script><p>对应上采样的计算：</p><script type="math/tex; mode=display">x^{\text {up }}(n)=\left\{\begin{array}{cl}x(n / 2) & n=0,2,4, \ldots \\0 & \text { otherwise }\end{array} \Leftrightarrow X^{\text {up }}(Z)=X\left(z^{2}\right)\right.</script><hr><p>我们已经知道了如何上下采样了，现在只需要找到变换的函数了。根据数学公式的一堆推导（详细的参考课本，这里不再写了），我们可以得到关系式：</p><script type="math/tex; mode=display">\begin{array}{l}H_{0}(-z) G_{0}(z)+H_{1}(-z) G_{1}(z)=0 \\H_{0}(z) G_{0}(z)+H_{1}(z) G_{1}(z)=2\end{array}</script><p>满足上面的关系的 H 和 G 函数都可以。</p><p>对于一个图像，我们只需要在行和列上分别应用子带编码就可以得到图像的滤波器了：</p><p><img src="https://i.loli.net/2021/05/25/Bep1I7DqjzNKfSO.png" alt="2D separable filters" style="zoom:80%;" /></p><h2 id="哈尔变换（The-Haar-Transform）"><a href="#哈尔变换（The-Haar-Transform）" class="headerlink" title="哈尔变换（The Haar Transform）"></a>哈尔变换（The Haar Transform）</h2><p>哈尔变换基于<strong>哈尔函数</strong> $h_u(x)$，就是满足上面的一组函数，他们定义在0到1之间。</p><p>为了便于理解，我们先将哈尔变换近似为另一种基于矩阵的变换。函数变成了我们表示为矩阵相乘：$T=AFA^T$，其中 F 是 $N\times N$ 的图像, A 是 $N\times N$ 的变换矩阵，T 是变换的结果。而对于逆变换，有 $F=A^TTA$。</p><p>下面给出生成哈尔变换矩阵 A 的方法：</p><p>对于任意的一个整数 u，它可以被唯一分解为</p><script type="math/tex; mode=display">u = 2^p+q</script><p>p 是 u 中包含的最大的 2 幂次，而 q 是余数，定义哈尔基函数：</p><script type="math/tex; mode=display">h_u(x)=\left\{\begin{matrix} 1, & u=0和0\le x\lt1\\ 2^{\frac{p}{2}}, & u\gt0 和\frac{q}{2^p}\le x \lt \frac{(q+0.5)}{2^p}\\ -2^{\frac{p}{2}}, & u\lt0 和\frac{(q+0.5)}{2^p}\le x \lt \frac{(q+1)}{2^p} \\ 0,& 其他\end{matrix}\right.</script><p>哈尔矩阵的第 i 行包含了 $h_i(z), \quad z=0/N, 1/N, \cdots, (N-1)/N$</p><script type="math/tex; mode=display">\begin{eqnarray} H_N&=&\begin{bmatrix} h_0(\frac{0}{N}) & h_0(\frac{1}{N}) & \cdots & h_0(\frac{N-1}{N})\\ h_1(\frac{0}{N}) & h_1(\frac{1}{N}) & \cdots & h_1(\frac{N-1}{N})\\ \vdots & \vdots & \ddots  & \vdots \\ h_{N-1}(\frac{0}{N}) & h_{N-1}(\frac{1}{N}) & \cdots & h_{N-1}(\frac{N-1}{N}) \end{bmatrix} \\ \\ A_H &=& \frac{1}{\sqrt{N}}H_N\end{eqnarray}</script><p>如一个 4 阶的哈尔变换矩阵</p><script type="math/tex; mode=display">\begin{align}A_4 & = \frac{1}{2}\begin{bmatrix} 1 & 1 & 1 & 1\\ 1 & 1 & -1 & -1\\ \sqrt{2} & -\sqrt{2} & 0 & 0\\ 0 & 0 & \sqrt{2} & -\sqrt{2}\end{bmatrix}\end{align}</script><p>这样我们就构造好了变换：先按照上面的方法用对应的 $A_N$ 计算 T，然后下采样，再用对应 $A_{N/2}$ 计算 T……，要恢复的时候就用逆变换的公式得到 F，再上采样，再逆变换……</p><h2 id="基函数-amp-尺度函数"><a href="#基函数-amp-尺度函数" class="headerlink" title="基函数&amp;尺度函数"></a>基函数&amp;尺度函数</h2><p>我们理解了如何用矩阵去实现上面的子带编码的计算和恢复，但很明显，用矩阵的计算复杂度高，消耗时间，并且对于非正方形的图像需要补齐才能运算，带来了一定的误差。</p><p>尺度函数用于创建函数或图像的一些列逼近，每个逼近的分辨率与其最邻近逼近的分辨率相差 2 倍。并且使用称为<strong>小波</strong>的<strong>补函数</strong>对<strong>相邻逼近之间的差进行编码</strong>。简单来说就是通过尺度函数+小波函数来对频率域的图像进行近似。</p><p>这里开始就进入小波变换的内容了，<strong>离散小波变换（DWT）</strong>使用小波和一个尺度函数，将函数或者图像表示为小波和尺度函数的线性组合。</p><p>我们考虑由实的，平方可积的父尺度函数 $\varphi(x)$ 的所有整数平移和二元缩放组成的基函数集合 $\{\varphi_{j,k}(x)|j,k \in Z \}$，其中：</p><script type="math/tex; mode=display">\varphi_{j,k}(x)=2^{\frac{j}{2}} \varphi(2^jx-k)</script><p>整数 k 决定了平移的结果，尺度 j 决定了缩放（宽度和幅度），若固定 j，我们可以得到一个基函数的空间 $V_j$，增大 j 可以扩大这个空间，让更多的变换后的基函数加入到其中，也就能表示更多更小的细节。</p><h3 id="哈尔尺度函数"><a href="#哈尔尺度函数" class="headerlink" title="哈尔尺度函数"></a>哈尔尺度函数</h3><p>我们还以哈尔为例，考虑高度为 1，宽度为 1 的尺度函数。</p><script type="math/tex; mode=display">\varphi(x)=\left\{\begin{array}{ll}1, & 0 \leq x<1 \\0, & \text { otherwise }\end{array}\right.</script><p>由这个父函数生成的一系列尺度函数：</p><p><img src="https://i.loli.net/2021/05/27/PfpTvzOR72HwodF.png" alt="" style="zoom: 75%;" /></p><p>而一个略微复杂的函数 $f$（e 图），可以用这些同一个尺度空间的尺度函数线性表示。</p><script type="math/tex; mode=display">f(x) = 0.5\varphi_{1,0}(x)+\varphi_{1,1}(x)-0.25\varphi_{1,4}(x)</script><p>上面是在尺度空间 $V_1$ 中的表示，我们同样也可以用 $V_0$ 尺度空间来表示，只需要将上面的尺度空间 $V_1$ 的基函数变换到 $V_0$ 空间即可：</p><script type="math/tex; mode=display">\varphi_{0,k}(x)=\frac{1}{\sqrt{2}}\varphi_{1,2k}(x)+\frac{1}{\sqrt{2}}\varphi_{1,2k+1}(x)</script><p>回忆起 $\varphi_{j,k}(x)$ 的定义，根据上面我们发现的规律，$\varphi(x)$ 可以表示为自身 2 倍分辨率副本的线性组合。（取 j=1）</p><script type="math/tex; mode=display">\varphi_(x)=\sum_{k\in Z}h_{\varphi}(k)\sqrt{2}\varphi(2x-k)</script><p>上式被称为膨胀方程，我们将展开的系数 $\{ h_{\varphi}(k)|k=0,1,2,\cdots \}$ 称为<strong>尺度函数系数</strong>。</p><p>对于哈尔尺度函数，可以计算出他的尺度函数的系数 $\{\varphi(k)|k=0,1 \} = \{ \frac{1}{\sqrt{2}},\frac{1}{\sqrt{2}} \}$：</p><script type="math/tex; mode=display">\begin{eqnarray}&\varphi(x) & = & \frac{1}{\sqrt{2}}\varphi_{1,0}(x)+\frac{1}{\sqrt{2}}\varphi_{1,1}(x) \\& & = & \frac{1}{\sqrt{2}}\left [ \sqrt{2}\varphi(2x) \right]+\frac{1}{\sqrt{2}}\left [ \sqrt{2}\varphi(2x+1) \right]\\\Rightarrow \quad& \varphi(x)&=& \varphi(2x)+\varphi(2x+1)\end{eqnarray}</script><h3 id="小波函数"><a href="#小波函数" class="headerlink" title="小波函数"></a>小波函数</h3><p>我们现在理论化前面的规律，对小波函数进行一般性的描述：</p><p>对于所有的 $j,k\in Z$，存在一个母函数$\psi_{j,k}(x)=2^{\frac{j}{2}} \psi(2^jx-k) $，若令 $W_{j_0}$ 表示由小波函数 $\{\psi_{j_0,k}|k\in Z \}$ 张成的函数空间，则：</p><script type="math/tex; mode=display">V_{j_0+1} = V_{j_0} \oplus W_{j_0}</script><p>$\oplus$ 表示函数空间集合的并集，并且作为$V_{j_0}$ 的基的尺度函数和作为 $W_{j_0}$ 的基的小波函数是正交的：</p><script type="math/tex; mode=display">\psi_{j_0,k}(x), \varphi_{j_0,l}(x)</script><p>尺度函数和小波空间的关系如下图：</p><p><img src="https://i.loli.net/2021/05/27/H1FxNgCw2jBJO7S.png" style="zoom: 50%;" /></p><p>小波函数（类似于前面提到的尺度函数）可以用平移且分辨率加倍后的尺度函数的加权和来表示，我们可以写出：</p><script type="math/tex; mode=display">\psi_{j_0,k}(x)=\sum_{k}h_{\psi}(k)\sqrt{2} \varphi_(2x-k)</script><p>其中 $h_{\psi}(k)$ 被称为小波系数。</p><p>可以证明：</p><script type="math/tex; mode=display">h_{\psi}(k)=(-1)^kh_{\varphi}(1-k)</script><p>对于一个不在函数空间内的一个函数 $f(x)$，可以把它写成小波函数和尺度函数的和 $f(x)=f_{\psi}(x)+f_{\varphi}(x)$</p><p>仍以哈尔小波函数为例，在前面我们计算出了哈尔尺度系数，可以求得对应的小波系数：</p><script type="math/tex; mode=display">\begin{eqnarray}h_{\psi}(0) & = & (-1)^0h_{\varphi}(1-0) =\frac{1}{\sqrt{2}}\\h_{\psi}(1) & = & (-1)^1h_{\varphi}(1-1) =-\frac{1}{\sqrt{2}}\end{eqnarray}</script><p>这两个系数对应 $A_H$ 矩阵的第二行，代入小波函数的表达式可得 $\psi(x)=\varphi(2x)-\varphi(2x-1)$，于是哈尔母小波函数是：</p><script type="math/tex; mode=display">\psi(x)=\left\{\begin{matrix} 1, & 0\le x \lt 0.5&\\ -1, & 0.5\le x \lt 1& \\ 0, & 其他&\end{matrix}\right.</script><h3 id="二维小波变换"><a href="#二维小波变换" class="headerlink" title="二维小波变换"></a>二维小波变换</h3><p>一维小波变换很容易扩展到二维，在二维情况下，需要 1 个尺度函数和 3 个二维小波$\psi^H(x,y), \psi^V(x,y), \psi^D(x,y)$，每个二维小波都是两个一维的积。排除产生了 1 维结果的积之后，剩下的 4 个积产生可分离的尺度函数：</p><script type="math/tex; mode=display">\varphi(x,y)=\varphi(x)\varphi(y)</script><p>和可分离的“方向敏感”小波：</p><script type="math/tex; mode=display">\begin{eqnarray}\psi^H(x,y) & = & \psi(x)\varphi(y)\\ \psi^V(x,y) & = & \varphi(x)\psi(y)\\ \psi^D(x,y) & = & \psi(x)\psi(y)\end{eqnarray}</script><p>V, D, H 分别表示小波度量图像中灰度延行（垂直边缘），对角线，列（水平边缘）的变化，他们分别表示行，对角线，列的高频信息，而 $\varphi(x,y)$ 就是图像的低频信息了。</p><p>课本上二维小波变换的示意图：<br><img src="https://i.loli.net/2021/05/27/Ywzngq5JQkTomyP.png" style="zoom: 67%;" /></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Python 的 <strong>PyWavelets</strong> 包提供了小波变换的库。</p><p>官方文档给出的示例代码，对单张图片进行小波变换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pywt</span><br><span class="line"><span class="keyword">import</span> pywt.data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load image</span></span><br><span class="line">original = pywt.data.camera()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Wavelet transform of image, and plot approximation and details</span></span><br><span class="line">titles = [<span class="string">&#x27;Approximation&#x27;</span>, <span class="string">&#x27; Horizontal detail&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Vertical detail&#x27;</span>, <span class="string">&#x27;Diagonal detail&#x27;</span>]</span><br><span class="line">coeffs2 = pywt.dwt2(original, <span class="string">&#x27;bior1.3&#x27;</span>)</span><br><span class="line">LL, (LH, HL, HH) = coeffs2</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">12</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>([LL, LH, HL, HH]):</span><br><span class="line">    ax = fig.add_subplot(<span class="number">1</span>, <span class="number">4</span>, i + <span class="number">1</span>)</span><br><span class="line">    ax.imshow(a, interpolation=<span class="string">&quot;nearest&quot;</span>, cmap=plt.cm.gray)</span><br><span class="line">    ax.set_title(titles[i], fontsize=<span class="number">10</span>)</span><br><span class="line">    ax.set_xticks([])</span><br><span class="line">    ax.set_yticks([])</span><br><span class="line"></span><br><span class="line">fig.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>LL, LH, HL, HH 分别代表低频信息，水平细节，垂直细节和对角线细节，结果如图：</p><p><img src="https://pywavelets.readthedocs.io/en/latest/_images/camera_approx_detail.png" alt=""></p><h3 id="多阶小波"><a href="#多阶小波" class="headerlink" title="多阶小波"></a>多阶小波</h3><p>如果想要多阶的小波变换，就需要 <code>wavedec2</code> 函数，它的返回值是一个列表 <code>[cAn, (cHn, cVn, cDn), … (cH1, cV1, cD1)]</code> 第一个值是低频信息，第二个元组是从第 n 层到第 1 层 3 个维度的高频信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ......</span></span><br><span class="line">scales = pywt.wavedec2(img, <span class="string">&quot;haar&quot;</span>, level=<span class="number">4</span>)</span><br><span class="line">base = scales[<span class="number">0</span>]</span><br><span class="line">fourth_layer = scales[<span class="number">1</span>]</span><br><span class="line">third_layer = scales[<span class="number">2</span>]</span><br><span class="line">second_layer = scales[<span class="number">3</span>]</span><br><span class="line">first_layer = scales[<span class="number">4</span>]</span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure><p>对于反变换，和傅里叶变换时使用的库的函数命名方式很相似，均是以 “ixxx” 开头的函数。如 <code>dwt2</code> 对应 <code>idwt2</code>， <code>wavedec2</code> 对应 <code>waverec2</code>，系数的形式要和使用 <code>wavedec2</code> 得到的结构一致。</p><h3 id="小波去噪"><a href="#小波去噪" class="headerlink" title="小波去噪"></a>小波去噪</h3><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>学起来的时候还真是反复看了好多边，再加上一些资料，才感觉有一丝丝的理解了……，真的难，本人菜鸡，有问题还请指出。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>数字图像处理第四版（冈萨雷斯）</li><li><a href="users.rowan.edu/~polikar/WTtutorial.html">The Wavelet Tutorial</a></li><li><a href="https://blog.csdn.net/qq_18343569/article/details/46912929">图像的多分辨率金字塔</a></li><li><a href="https://blog.csdn.net/hhaowang/article/details/102533040">OpenCV教程（25）图像金字塔</a></li><li><a href="https://wenku.baidu.com/view/41ddf4eab52acfc788ebc900.html">小波变换和多分辨率处理（百度文库）</a></li><li><a href="https://baike.baidu.com/item/%E5%B0%8F%E6%B3%A2%E5%88%86%E6%9E%90/1504577?fr=aladdin">小波分析（百度百科）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;2021/5/28: 增加了部分示例代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;小波变换&quot;&gt;&lt;a href=&quot;#小波变换&quot; class=&quot;headerlink&quot; title=&quot;小波变换&quot;&gt;&lt;/a&gt;小波变换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;小波 (Wavelet) 是时间（空间）频率的局部化分析，它通过伸缩平移运算对信号(函数)逐步进行多尺度细化，最终达到高频处时间细分，低频处频率细分，能自动适应时频信号分析的要求，从而可聚焦到信号的任意细节。有人把小波变换称为“数学显微镜”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而对于图像处理相关领域，小波变换曾经相当的热门，一些经典的算法如 JPEG-2000 就是基于小波变换原理的。&lt;/p&gt;
&lt;p&gt;要理解小波变换，有一大堆需要铺垫的东西……&lt;/p&gt;</summary>
    
    
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/categories/Digital-Image-Processing/"/>
    
    
    <category term="CV" scheme="http://cyx0706.github.io/tags/CV/"/>
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>Take Your Time</title>
    <link href="http://cyx0706.github.io/2021/05/25/busyday/"/>
    <id>http://cyx0706.github.io/2021/05/25/busyday/</id>
    <published>2021-05-24T16:57:00.000Z</published>
    <updated>2021-07-07T08:02:49.311Z</updated>
    
    <content type="html"><![CDATA[<p>最近期末考试的安排出来了，学期末要来了，一学期又要结束了，说实话这学期懈怠了好多。</p><p>夏令营在紧张的准备中，联系的导师大多不回复，一度觉得自己要没学上了，加上同学给的压力有点大，好不容易调平心态了，就接着写博客呗…..</p><p>icarus 最近更新了，加入了自定义不同页面的显示，再也不用之前改代码了，是时候翻新一下博客的样式了！图片标题的问题实在是太难看了，顺便如果可以还是直接在页面渲染出来 latex 公式好看，插入图片有点对不齐显得很丑！</p><p>更多的<del>废话</del>放在 more 中了。<br><a id="more"></a></p><ul><li><p>参加了中兴的中兴捧月比赛，很幸运冲进了复赛，苦战 5 天，尽人事了，决赛要有机会我必去陪跑+旅游，想起了我经常出去打比赛的好朋友 AiDai，我也有机会体验一波了。</p></li><li><p>这学期上了数字图像处理这门课，竟然只有5个人。</p><ul><li>问，人去哪里了？答，选微信小程序开发去了。</li><li>问，提前学点CV不香吗？答，分高事少不香吗？</li></ul></li></ul><p>前几天还和学长们聊这个话题，无奈之中还是无奈。大家都想保研，都想不努力就搞高分（我也想啊！可恶）。</p><ul><li>问，你学为啥要学计算机，你要读什么方向的？</li><li>答，收入高啊，热门啊，大家都来了我也来了，研究生目前方向还不清楚。</li><li>问，你为啥不选 xxx （一门挺重要的课）啊？</li><li>答，我这个模块分够了，我选这个还拉我分我为啥要选，xxx（某班第一）也没选。</li></ul><p>我承认自己考试比不过这些人，但我觉得，在考试之外，还有应该更加看重的东西，个人目标，理想，抱负，兴趣难道仅仅是钱多就可以打发的吗？</p><ul><li><p>数字图像处理挺难的（没人选的原因之一？），但一点点来花上时间还是可以弄明白的，数学是个好东西，可惜我会的太少了。</p></li><li><p>Coursera 上吴恩达老师的机器学习课程听着挺香的，力推，难度适中，还有练习题，趁着补了补机器学习的基础。</p></li><li><p>五一时看的漫画《妖精的尾巴》陆陆续续补完了。很向往工会伙伴们的友谊，故事也迎来了圆满的结局，找回来看王道少年漫的感觉，真好。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近期末考试的安排出来了，学期末要来了，一学期又要结束了，说实话这学期懈怠了好多。&lt;/p&gt;
&lt;p&gt;夏令营在紧张的准备中，联系的导师大多不回复，一度觉得自己要没学上了，加上同学给的压力有点大，好不容易调平心态了，就接着写博客呗…..&lt;/p&gt;
&lt;p&gt;icarus 最近更新了，加入了自定义不同页面的显示，再也不用之前改代码了，是时候翻新一下博客的样式了！图片标题的问题实在是太难看了，顺便如果可以还是直接在页面渲染出来 latex 公式好看，插入图片有点对不齐显得很丑！&lt;/p&gt;
&lt;p&gt;更多的&lt;del&gt;废话&lt;/del&gt;放在 more 中了。&lt;br&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://cyx0706.github.io/2021/05/08/dip2/"/>
    <id>http://cyx0706.github.io/2021/05/08/dip2/</id>
    <published>2021-05-08T14:01:16.000Z</published>
    <updated>2021-05-25T13:43:13.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图像复原与重建"><a href="#图像复原与重建" class="headerlink" title="图像复原与重建"></a>图像复原与重建</h1><p>对于一些周期性噪声，空间滤波器的效果不会很好，而且会比较麻烦。在前面的一篇中，我们提到了，除了空间域，我们还可以在频率域进行滤波。这种变换的基本思想是：在傅里叶变换中，周期噪声在对应于周期干扰的频率处显示为集中突发的能量。方法是通过一个选择性滤波器来分离噪声。<br><a id="more"></a></p><p>带阻滤波器属于选择性滤波，包括后面两种带通滤波器和陷波滤波器，也都是选择性滤波器。它们区别于上一篇里面的滤波器的地方在于，它们只关注处理特定的频带或小频矩形区域。</p><ul><li>如果某个频带中的频率被滤除，则称该频带滤波器为<strong>带阻滤波器</strong></li><li>如果某个频带中的频率被通过，则称该频带滤波器为<strong>带通滤波器</strong></li><li>小频率矩形区域处理中的滤波器称为<strong>陷波滤波器</strong></li></ul><h2 id="带阻滤波器"><a href="#带阻滤波器" class="headerlink" title="带阻滤波器"></a>带阻滤波器</h2><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><ul><li><p>理想带阻滤波器（IBRF）</p><script type="math/tex; mode=display">\begin{align*}H(u,v) = \left\{\begin{matrix}0,& C_0-\frac{W}{2} \le D(u,v) \le C_0+\frac{W}{2} \\1,& \quad others\end{matrix}\right.\end{align*}</script></li><li><p>高斯带阻滤波器（GBRF）</p><script type="math/tex; mode=display">H(u,v) = 1 - exp(-\left [ \frac{D^2(u,v)-C_0^2}{D(u,v)W} \right ]^2 )</script></li><li><p>巴特沃斯带阻滤波器（BBRF）</p></li></ul><script type="math/tex; mode=display">H(u,v) = \frac{1}{1+\left [ \frac{D(u,v)W}{D^2(u,v)-C_0^2} \right ]^{2n} }</script><p>其中 $C_0$ 是频带中心，$W$ 是带宽, $D(u,v)$ 是传递函数得到中心到频率矩形中点 $(u,v)$ 的距离。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">pa, pb</span>):</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">    dis = sqrt((pa[<span class="number">0</span>] - pb[<span class="number">0</span>]) ** <span class="number">2</span> + (pa[<span class="number">1</span>] - pb[<span class="number">1</span>]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_filter</span>(<span class="params">cls, d, shape, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="comment"># 这里要反过来 shape 的两个维度</span></span><br><span class="line">        transfer_matrix = np.zeros((shape[<span class="number">0</span>], shape[<span class="number">1</span>]))</span><br><span class="line">        center_point = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x - <span class="number">1</span>) // <span class="number">2</span>, shape))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">1</span>]):</span><br><span class="line">                dist = cal_distance(center_point, (i, j))</span><br><span class="line">                transfer_matrix[i, j] = cls.get_one(d, dist, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> transfer_matrix</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BBRFFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        w = kwargs[<span class="string">&quot;w&quot;</span>]</span><br><span class="line">        n = kwargs[<span class="string">&quot;n&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> dist == d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + ((dist * w) / (dist ** <span class="number">2</span> - d ** <span class="number">2</span>)) ** (<span class="number">2</span> * n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GBRFFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        w = kwargs[<span class="string">&quot;w&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>-np.exp(-((dist ** <span class="number">2</span> - d ** <span class="number">2</span>) / (d * w)) ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IBRFFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        w = kwargs[<span class="string">&quot;w&quot;</span>]</span><br><span class="line">        <span class="keyword">if</span> d - w / <span class="number">2</span> &lt;= dist &lt;= d + w / <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abs_threshold_filter</span>(<span class="params">matrix</span>):</span></span><br><span class="line">    matrix = np.<span class="built_in">abs</span>(matrix)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">choice = <span class="string">&quot;material/windmill_noise.png&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(choice).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line">f_shift = np.fft.fftshift(f)</span><br><span class="line">choices = &#123;</span><br><span class="line">    <span class="string">&quot;巴特沃斯带阻&quot;</span>: BBRFFilter.generate_filter(<span class="number">15</span>, (img.size[<span class="number">1</span>], img.size[<span class="number">0</span>]), n=<span class="number">3</span>, w=<span class="number">5</span>),</span><br><span class="line">    <span class="string">&quot;高斯带阻&quot;</span>: GBRFFilter.generate_filter(<span class="number">15</span>, (img.size[<span class="number">1</span>], img.size[<span class="number">0</span>]), w=<span class="number">5</span>),</span><br><span class="line">    <span class="string">&quot;理想带阻&quot;</span>: IBRFFilter.generate_filter(<span class="number">15</span>, (img.size[<span class="number">1</span>], img.size[<span class="number">0</span>]), w=<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> choices.items():</span><br><span class="line">    filter_matrix = v</span><br><span class="line">    transform_img = np.<span class="built_in">abs</span>(np.fft.ifft2(np.fft.ifftshift(f_shift*filter_matrix)))</span><br><span class="line"></span><br><span class="line">    plt.imshow(transform_img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.savefig(<span class="string">&quot;&#123;&#125;.png&quot;</span>.<span class="built_in">format</span>(k))</span><br><span class="line">    plt.clf()</span><br></pre></td></tr></table></figure><p>下面是代码的运行结果，左边的是滤波后的图片，右边的是原图片（带有周期性噪声）。整体来看，高斯滤波效果看起来最差，周期性的黑白条纹没有完全消除。巴特沃斯方法得到的效果看起来更好，基本消除了黑白条纹噪声。</p><ul><li>巴特沃斯带阻滤波</li></ul><div align=center><img src="https://i.loli.net/2021/05/09/7bZqwuHT4CoEUyz.png"></div><ul><li>理想带阻滤波</li></ul><div align=center><img src="https://i.loli.net/2021/05/09/aNOBD85G2doTby9.png"></div><ul><li>高斯带阻滤波</li></ul><div align=center><img src="https://i.loli.net/2021/05/09/8OuvqkD9ENJMhIl.png"></div><h2 id="带通滤波器"><a href="#带通滤波器" class="headerlink" title="带通滤波器"></a>带通滤波器</h2><h2 id="陷波滤波器"><a href="#陷波滤波器" class="headerlink" title="陷波滤波器"></a>陷波滤波器</h2><h2 id="自适应中值法"><a href="#自适应中值法" class="headerlink" title="自适应中值法"></a>自适应中值法</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;图像复原与重建&quot;&gt;&lt;a href=&quot;#图像复原与重建&quot; class=&quot;headerlink&quot; title=&quot;图像复原与重建&quot;&gt;&lt;/a&gt;图像复原与重建&lt;/h1&gt;&lt;p&gt;对于一些周期性噪声，空间滤波器的效果不会很好，而且会比较麻烦。在前面的一篇中，我们提到了，除了空间域，我们还可以在频率域进行滤波。这种变换的基本思想是：在傅里叶变换中，周期噪声在对应于周期干扰的频率处显示为集中突发的能量。方法是通过一个选择性滤波器来分离噪声。&lt;br&gt;</summary>
    
    
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/categories/Digital-Image-Processing/"/>
    
    
    <category term="CV" scheme="http://cyx0706.github.io/tags/CV/"/>
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://cyx0706.github.io/2021/04/23/dip1/"/>
    <id>http://cyx0706.github.io/2021/04/23/dip1/</id>
    <published>2021-04-23T01:43:40.000Z</published>
    <updated>2021-04-24T04:47:09.399Z</updated>
    
    <content type="html"><![CDATA[<p>2021/4/24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了<a href="https://github.com/MakerGYT/markdown-it-latex2img">服务器渲染</a></p><h1 id="空间-amp-频率域滤波"><a href="#空间-amp-频率域滤波" class="headerlink" title="空间&amp;频率域滤波"></a>空间&amp;频率域滤波</h1><p>用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼）</p><h2 id="空间域滤波"><a href="#空间域滤波" class="headerlink" title="空间域滤波"></a>空间域滤波</h2><h3 id="直方图均衡化"><a href="#直方图均衡化" class="headerlink" title="直方图均衡化"></a>直方图均衡化</h3><p>直方图的形状往往与图像的外观有关。</p><ul><li>在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0）</li><li>亮的图像的直方图中，多数直方图容器集中在灰度级的高端</li><li>低对比度的图像的直方图中，直方图容器基本位于灰度级的中间</li><li>高对比度图像的直方图，容器覆盖了较宽的范围，并且像素的分布是基本均匀的<a id="more"></a>直方图均衡化的数学原理我们暂且不提，假如我们把直方图每个部分出现频率和总统计量做除法，得到一个概率分布函数$p_r(r)$，均衡化变换就是将一个概率分布不规则，不均匀的$p_r(r)$变化为分布均匀的新的函数$p_s(s)$。</li></ul><p>Python 代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分不同的空间来绘图</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(<span class="string">&quot;./IMG_2546.JPG&quot;</span>).convert(<span class="string">&quot;L&quot;</span>)  <span class="comment"># 转为灰度图</span></span><br><span class="line">img_array = np.array(img)</span><br><span class="line">x_num, y_num = img.size</span><br><span class="line"><span class="comment"># 查看直方图</span></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.hist(img_array.flatten(), <span class="number">256</span>)  <span class="comment"># 变换成 1 维再绘制直方图</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用直方图均衡再查看直方图</span></span><br><span class="line"><span class="comment"># 每个 bins 数组的区间值对应一个 im_hist 数组中的强度值</span></span><br><span class="line">im_hist, bins = np.histogram(img_array.flatten(), <span class="number">256</span>, density=<span class="literal">True</span>)  <span class="comment"># 转化为直方图</span></span><br><span class="line">cdf = im_hist.cumsum()  <span class="comment"># 计算累计分布函数 cumulative distribution function</span></span><br><span class="line"><span class="comment"># cdf(a)=P(x&lt;=a)</span></span><br><span class="line">cdf = <span class="number">255</span> * (cdf / cdf[-<span class="number">1</span>])  <span class="comment"># 归一化到 0-1 之后转化到 0-255</span></span><br><span class="line"><span class="comment"># interp(x, xp, yp)输入原函数的一系列点(xp, yp)使用线性插值方法模拟函数并计算 f(x)</span></span><br><span class="line"><span class="comment"># s = cdf(r)</span></span><br><span class="line">img_array_transformed = np.interp(img_array.flatten(), bins[:<span class="number">256</span>], cdf)</span><br><span class="line"><span class="comment"># 变换回原来的数组结构后转为图片</span></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.hist(img_array_transformed, <span class="number">256</span>)</span><br><span class="line">plt.xticks([])</span><br><span class="line">plt.yticks([])</span><br><span class="line">plt.savefig(<span class="string">&quot;exp.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>原直方图和均衡化后的图片的直方图：</p><p><img src="https://i.loli.net/2021/04/15/v5HmMwd6icXlhzS.png" alt="直方图均衡化.png"></p><p>原图和均衡化后的图的对比：</p><p><img src="https://i.loli.net/2021/04/15/A18ByaERU6ZMH5v.png" alt="原图.png"></p><p><img src="https://i.loli.net/2021/04/15/7lEKRXDQhBZ15SW.png" alt="均衡化后.png"></p><p>如果我们对局部直方图均衡化，还可以显示出全局直方图均衡化无法显示的灰度细节。</p><h3 id="低通空间滤波器"><a href="#低通空间滤波器" class="headerlink" title="低通空间滤波器"></a>低通空间滤波器</h3><ul><li>高斯核</li></ul><p><img src="https://i.loli.net/2021/04/15/lAeMogtphx1cRS8.png" alt="3x3高斯核"></p><p>有现成的库可以调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line">img = img.<span class="built_in">filter</span>(ImageFilter.GaussianBlur(radius=<span class="number">2</span>))</span><br></pre></td></tr></table></figure></p><h3 id="高通空间滤波器"><a href="#高通空间滤波器" class="headerlink" title="高通空间滤波器"></a>高通空间滤波器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> signal</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sharpening_f</span>(<span class="params">img_array, kernel, c</span>):</span></span><br><span class="line">    <span class="comment"># 卷积锐化图像</span></span><br><span class="line"></span><br><span class="line">    new_array = signal.convolve2d(img_array, kernel,</span><br><span class="line">                                  boundary=<span class="string">&#x27;symm&#x27;</span>,</span><br><span class="line">                                  mode=<span class="string">&#x27;same&#x27;</span>)</span><br><span class="line">    new_array[new_array &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    new_array[new_array &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    new_array = img_array + c*new_array</span><br><span class="line">    new_array[new_array &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    new_array[new_array &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> new_array</span><br></pre></td></tr></table></figure><ul><li>Sobel</li></ul><p>横方向的 Sobel 算子，用于提取出水平方向的边界：</p><script type="math/tex; mode=display">\begin{bmatrix} -1 & 0 & 1\\ 2 & 0 & 2\\ -1 & 0 & 1\end{bmatrix}</script><ul><li>拉普拉斯</li></ul><p>拉普拉斯是导数算子，因此会突出图像中急剧的灰度过渡，并不强调缓慢变化的灰度区域，这会使得原图像产生灰色边缘线和其他不连续的特征，因此将原图像与拉普拉斯变换后的图像相加就能够恢复背景特征，并且保留拉普拉斯锐化的效果。</p><p>一种拉普拉斯核如下：</p><script type="math/tex; mode=display">\begin{bmatrix} 1 & 1 & 1\\ 1 & -8 & 1\\ 1 & 1 & 1\end{bmatrix}</script><p>又或者是：</p><script type="math/tex; mode=display">\begin{bmatrix} 0 & 1 & 0\\ 1 & -4 & 1\\ 0 & 1 & 0\end{bmatrix}</script><ul><li>钝化掩蔽</li></ul><p>分为三个步骤：</p><ol><li>模糊原图像</li><li>从原图中减去模糊后的图像（产生的差称为模板）</li><li>将模板与原图像相加</li></ol><p>令 $\bar{f}(x, y)$ 表示模糊后的图像，钝化掩蔽的过程可以用公式表示为：</p><script type="math/tex; mode=display">\left\{\begin{matrix}g_{mask}(x, y) = f(x, y) - \bar{f}(x, y)  \\ g(x, y) = f(x, y)+kg_{mask}(x, y)\end{matrix}\right.</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&quot;./IMG_2546.JPG&quot;</span>).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">origin_array = np.array(image)</span><br><span class="line">blurred_image = image.<span class="built_in">filter</span>(ImageFilter.BLUR)</span><br><span class="line">blurred_array = np.array(blurred_image)</span><br><span class="line">mask_array = origin_array - blurred_array</span><br><span class="line"></span><br><span class="line">weight_k = <span class="number">2</span></span><br><span class="line">new_array = origin_array + weight_k * mask_array</span><br><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">ax1.hist(origin_array.flatten(), <span class="number">256</span>)</span><br><span class="line">ax1.set_title(<span class="string">&quot;Origin&quot;</span>)</span><br><span class="line">ax2.hist(new_array.flatten(), <span class="number">256</span>)</span><br><span class="line">ax2.set_title(<span class="string">&quot;shielding Sharpened&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;exp6_sharping2.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>原图像：<br><img src="https://i.loli.net/2021/04/24/fOHkQztd3SYwa8c.png" alt="原图"></p><p>增强后的图像：<br><img src="https://i.loli.net/2021/04/24/pXlqekVEhW4NJro.png" alt="钝化掩蔽后的图像"></p><p>可以看到，我们仅仅是把 k 设置为 2，就出现了边界线。当 $k = 1$ 称为钝化掩蔽，$k &gt; 1$ 时被称为高提升滤波，选择 $k &lt; 1$ 可以减少钝化模板的贡献。</p><h2 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h2><p>在深度学习出来前，频率域滤波一直是数字图像处理的比较热门的研究点（我们老师说的），频率域滤波的功能还是挺强大的，同样关于原理不过多介绍。</p><h3 id="FFT-amp-频谱"><a href="#FFT-amp-频谱" class="headerlink" title="FFT&amp;频谱"></a>FFT&amp;频谱</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fft_transform</span>(<span class="params">in_path, name, out_path=<span class="string">&quot;.&quot;</span></span>):</span></span><br><span class="line">    image = Image.<span class="built_in">open</span>(in_path)</span><br><span class="line">    plt.subplot(<span class="number">221</span>)</span><br><span class="line">    plt.imshow(image)</span><br><span class="line">    <span class="comment"># 关闭坐标轴</span></span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Origin Image&quot;</span>)</span><br><span class="line">    image = image.convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">222</span>)</span><br><span class="line">    plt.imshow(image, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;Gray Image&quot;</span>)</span><br><span class="line">    <span class="comment"># 进行傅立叶变换，并显示结果</span></span><br><span class="line">    fft2 = np.fft.fft2(image)</span><br><span class="line">    <span class="comment"># 取 log</span></span><br><span class="line">    log_fft2 = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(fft2))</span><br><span class="line">    <span class="comment"># 将图像变换的原点移动到频域矩形的中心，并显示效果</span></span><br><span class="line">    shift2center = np.fft.fftshift(fft2)</span><br><span class="line">    <span class="comment"># 对中心化后的结果进行对数变换</span></span><br><span class="line">    log_shift2center = np.log(<span class="number">1</span> + np.<span class="built_in">abs</span>(shift2center))</span><br><span class="line">    plt.subplot(<span class="number">223</span>)</span><br><span class="line">    plt.imshow(np.absolute(shift2center), <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;shift2center&quot;</span>)</span><br><span class="line">    plt.subplot(<span class="number">224</span>)</span><br><span class="line">    plt.imshow(log_shift2center, <span class="string">&quot;gray&quot;</span>)</span><br><span class="line">    plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">    plt.title(<span class="string">&quot;log_shift2center&quot;</span>)</span><br><span class="line">    plt.savefig(os.path.join(out_path, (<span class="string">&quot;fft_transformed_&quot;</span> + name)))</span><br><span class="line">    <span class="comment"># clear all figure</span></span><br><span class="line">    plt.clf()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/24/Ley6mGWhobpKzBi.png" alt="fft_transformed.png"></p><p>需要注意的是要对变换后的图像取 log，不然值太大会无法在正常的灰度级下显示。</p><h3 id="高低通滤波器"><a href="#高低通滤波器" class="headerlink" title="高低通滤波器"></a>高低通滤波器</h3><p>课本上介绍的 3 个高通滤波器：</p><ul><li>理想高通滤波器<script type="math/tex; mode=display">H(u,v)=\left\{\begin{matrix}0, & D(u,v)\le D_0\\1, & D(u,v)\gt D_0\end{matrix}\right.</script></li><li>高斯高通滤波器<script type="math/tex; mode=display">H(u,v)=1-e^{-D^2(u,v)/2D_0^2}</script></li><li>巴德沃斯高通滤波器<script type="math/tex; mode=display">H(u,v)=\frac{1}{1+\left [ D_0/D(u,v) \right ]^{2n}}</script></li></ul><p>其中 $D_0$ 表示截止频率到矩阵中心的距离，$D(u,v)$ 表示频率矩阵中心到矩阵中任意一点的距离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal_distance</span>(<span class="params">pa, pb</span>):</span></span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">    dis = sqrt((pa[<span class="number">0</span>] - pb[<span class="number">0</span>]) ** <span class="number">2</span> + (pa[<span class="number">1</span>] - pb[<span class="number">1</span>]) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> dis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Filter</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_filter</span>(<span class="params">cls, d, shape, *args, **kwargs</span>):</span></span><br><span class="line">        transfer_matrix = np.zeros(shape)</span><br><span class="line">        center_point = <span class="built_in">tuple</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: (x - <span class="number">1</span>) // <span class="number">2</span>, shape))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(transfer_matrix.shape[<span class="number">1</span>]):</span><br><span class="line">                dist = cal_distance(center_point, (i, j))</span><br><span class="line">                transfer_matrix[i, j] = cls.get_one(d, dist, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> transfer_matrix</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILPFLowPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dist &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ILPFHighPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">if</span> dist &lt;= d:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaussianHighPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> - np.exp(-(dist ** <span class="number">2</span>) / (<span class="number">2</span> * (d ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GaussianLowPassFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        <span class="keyword">return</span> np.exp(-(dist ** <span class="number">2</span>) / (<span class="number">2</span> * (d ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ButterworthFilter</span>(<span class="params">Filter</span>):</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span>(<span class="params">cls, d, dist, *args, **kwargs</span>) -&gt; <span class="built_in">float</span>:</span></span><br><span class="line">        n = kwargs[<span class="string">&quot;n&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / ((<span class="number">1</span> + dist / d) ** (<span class="number">2</span> * n))</span><br></pre></td></tr></table></figure><p>使用滤波器进行滤波：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">choice = <span class="string">&quot;material/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(choice).convert(<span class="string">&quot;L&quot;</span>)</span><br><span class="line"></span><br><span class="line">sq = <span class="built_in">min</span>(img.size[<span class="number">0</span>], img.size[<span class="number">1</span>])</span><br><span class="line">img = img.resize((sq, sq))</span><br><span class="line">f = np.fft.fft2(img)</span><br><span class="line">f_shift = np.fft.fftshift(f)</span><br><span class="line"><span class="comment"># gauss_filter_matrix = GaussianLowPassFilter.generate_filter(50, img.size)</span></span><br><span class="line">butter_filter_matrix = ButterworthFilter.generate_filter(<span class="number">30</span>, img.size, n=<span class="number">2</span>)</span><br><span class="line">filter_matrix = np.fft.ifftshift(f_shift*butter_filter_matrix)</span><br><span class="line">transform_img = np.<span class="built_in">abs</span>(np.fft.ifft2(filter_matrix))</span><br><span class="line">plt.axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plt.imshow(transform_img, cmap=<span class="string">&quot;gray&quot;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;gauss_filter.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="扩展：人脸磨皮算法"><a href="#扩展：人脸磨皮算法" class="headerlink" title="扩展：人脸磨皮算法"></a>扩展：人脸磨皮算法</h1><h2 id="Bilateral"><a href="#Bilateral" class="headerlink" title="Bilateral"></a>Bilateral</h2><p>双边滤波（Bilateral filter）结合图像的空间邻近度和像素值相似度，同时考虑空域信息和灰度相似性，达到保边去噪的目的。</p><p>它的滤波器核由两个函数生成：空间域核和值域核。</p><p>空间域核是由像素位置欧式距离决定的模板权值，公式：</p><script type="math/tex; mode=display">w_d(i,j,k,l)=exp(-\frac{(i-k)^2+(i-l)^2}{2\delta_d^2})</script><p>其中i,j 代表的是当前坐标点的位置 k，l 为中心坐标点，$\delta_d$ 代表高斯函数的标准差。很明显 $w_d$ 是计算临近点 ij 到中心点的临近程度，因此空间域核是用于衡量空间临近的程度。这代表空间域的高斯函数。</p><p>值域核是由灰度像素值的差值决定模板的权值的：</p><script type="math/tex; mode=display">w_r(i,j,k,l)=exp(-\frac{(f(i,j)-f(k,l))^2}{2\delta_r^2})</script><p>$f(i,j)$代表每个点的灰度像素值，$f(k,l)$代表中点的像素值，$\delta_r$也是值域核下高斯函数的标准差。将两者相乘就能得到双边滤波的模板权值：</p><script type="math/tex; mode=display">w(i,j,k,l)=w_d(i,j,k,l)*w_r(i,j,k,l)=exp(-\frac{(i-k)^2+(i-l)^2}{2\delta_d^2}-\frac{(f(i,j)-f(k,l))^2}{2\delta_r^2})</script><p>化简：</p><script type="math/tex; mode=display">g(i,j)=\frac{\sum_{kl}f(k,l)w(i,j,k,l)}{\sum_{kl}w(i,j,k,l)}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公式看起来实现起来好麻烦，还好有库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">file_name = <span class="string">&#x27;./material/4.jpg&#x27;</span></span><br><span class="line">image = cv2.imread(file_name)</span><br><span class="line"></span><br><span class="line">dst = cv2.bilateralFilter(src=image, d=<span class="number">0</span>, sigmaColor=<span class="number">100</span>, sigmaSpace=<span class="number">15</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Source&quot;</span>, image)</span><br><span class="line">cv2.imshow(<span class="string">&quot;Filter&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/21/dm7hzjEcTlV2Qqu.png" alt="bilateral.png"></p><h2 id="表面模糊"><a href="#表面模糊" class="headerlink" title="表面模糊"></a>表面模糊</h2><p>图像的表面模糊处理，其作用是在保留图像边缘的情况下，对图像的表面进行模糊处理。在对人物皮肤处理上，比高斯模糊更有效。（高斯模糊在使人物皮肤光洁的同时，也将一些边缘特征给模糊了）</p><p>在处理手法上，表面模糊也与前面提到的卷积处理手段不同，表面模糊是每一个像素点都有自己的卷积矩阵，而且还是 3 套，用以对应于像素的 R、G、B 分量。</p><p>表面模糊有 2 个参数，即模糊半径 r 和模糊阈值 T，模糊半径确定模糊的范围，而模糊范围确定的是卷积矩阵的大小，模糊矩阵是一个长宽相等的矩阵，长度 $l=2r+1$。</p><p>矩阵的中间元素是当前的像素点，其余的元素按照下面的方法计算：</p><script type="math/tex; mode=display">w_{ij}=1-\frac{\left | I_{ij}-I_0 \right | }{2.5T}</script><p>$I_{ij}$ 是图像值，$I_0$是模板矩阵中心的图像值</p><p>一般来说，会有预处理： $w_{ij}=max(0, w_{ij})$</p><p>根据卷积运算，每个像素通过表面模糊之后的值为：</p><script type="math/tex; mode=display">w_{ij}=\frac{\sum w_{ij}I_{ij}}{\sum w_{ij}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表面模糊算法</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sur_blur</span>(<span class="params">origin, threshold, r</span>):</span></span><br><span class="line">    transformed = origin * <span class="number">1.0</span></span><br><span class="line">    row, col = origin.shape</span><br><span class="line">    w_size = r * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r, row - <span class="number">1</span> - r):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(r, col - <span class="number">1</span> - r):</span><br><span class="line">            iij = origin[i-r: i+r+<span class="number">1</span>, j-r: j+r+<span class="number">1</span>]</span><br><span class="line">            i0 = numpy.ones([w_size, w_size]) * origin[i, j]</span><br><span class="line">            wij = <span class="number">1</span> - <span class="built_in">abs</span>(iij - i0) / (<span class="number">2.5</span> * threshold)</span><br><span class="line">            wij[wij &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">            tmp = iij * wij</span><br><span class="line">            transformed[i, j] = tmp.<span class="built_in">sum</span>() / wij.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> transformed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">file_name = <span class="string">&#x27;./material/4.jpg&#x27;</span></span><br><span class="line">img = io.imread(file_name)</span><br><span class="line">img_out = img * <span class="number">1.0</span></span><br><span class="line">boundary = <span class="number">20</span></span><br><span class="line">half_size = <span class="number">10</span></span><br><span class="line">img_out[:, :, <span class="number">0</span>] = sur_blur(img[:, :, <span class="number">0</span>], boundary, half_size)</span><br><span class="line">img_out[:, :, <span class="number">1</span>] = sur_blur(img[:, :, <span class="number">1</span>], boundary, half_size)</span><br><span class="line">img_out[:, :, <span class="number">2</span>] = sur_blur(img[:, :, <span class="number">2</span>], boundary, half_size)</span><br><span class="line"></span><br><span class="line">img_out = img_out / <span class="number">255</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.imshow(img_out)</span><br><span class="line">plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">plt.savefig(<span class="string">&quot;surface_blur.png&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果挺好，就是算的有点慢：<br><img src="https://i.loli.net/2021/04/24/6W2wB7e5Jriu9Kb.png" alt="surface_blur.png"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li>数字图像处理（第四版），冈萨雷斯</li><li><a href="https://zhuanlan.zhihu.com/p/118496347">高斯滤波和双边滤波原理和python实现</a></li><li><a href="https://blog.csdn.net/zb1165048017/article/details/107798789">一个简单好用的磨皮祛斑算法理论和python实现</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;2021/4/24: 解决(?)公式渲染问题，卸了重装了渲染器，然后参考配置了&lt;a href=&quot;https://github.com/MakerGYT/markdown-it-latex2img&quot;&gt;服务器渲染&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;空间-amp-频率域滤波&quot;&gt;&lt;a href=&quot;#空间-amp-频率域滤波&quot; class=&quot;headerlink&quot; title=&quot;空间&amp;amp;频率域滤波&quot;&gt;&lt;/a&gt;空间&amp;amp;频率域滤波&lt;/h1&gt;&lt;p&gt;用于记录学习数字图像处理的历程（不完全同步学校课程，不定期摸鱼）&lt;/p&gt;
&lt;h2 id=&quot;空间域滤波&quot;&gt;&lt;a href=&quot;#空间域滤波&quot; class=&quot;headerlink&quot; title=&quot;空间域滤波&quot;&gt;&lt;/a&gt;空间域滤波&lt;/h2&gt;&lt;h3 id=&quot;直方图均衡化&quot;&gt;&lt;a href=&quot;#直方图均衡化&quot; class=&quot;headerlink&quot; title=&quot;直方图均衡化&quot;&gt;&lt;/a&gt;直方图均衡化&lt;/h3&gt;&lt;p&gt;直方图的形状往往与图像的外观有关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在暗图像的直方图中，大多数直方图容器集中在灰度级较低的一端（靠近 0）&lt;/li&gt;
&lt;li&gt;亮的图像的直方图中，多数直方图容器集中在灰度级的高端&lt;/li&gt;
&lt;li&gt;低对比度的图像的直方图中，直方图容器基本位于灰度级的中间&lt;/li&gt;
&lt;li&gt;高对比度图像的直方图，容器覆盖了较宽的范围，并且像素的分布是基本均匀的</summary>
    
    
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/categories/Digital-Image-Processing/"/>
    
    
    <category term="CV" scheme="http://cyx0706.github.io/tags/CV/"/>
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>winter-2021</title>
    <link href="http://cyx0706.github.io/2021/03/19/winter-2021/"/>
    <id>http://cyx0706.github.io/2021/03/19/winter-2021/</id>
    <published>2021-03-19T03:14:08.000Z</published>
    <updated>2021-03-19T01:31:35.919Z</updated>
    
    <content type="html"><![CDATA[<p><del>诈尸</del></p><p>2021/3/19 开学第三周，挖出来，填一下实际完成的东西。<br><a id="more"></a></p><h1 id="今年"><a href="#今年" class="headerlink" title="今年"></a>今年</h1><p>一回学校就补了部番《机器人笔记》，不愧是我…</p><p>确实很喜欢，之前只是听过 “ROBOTICS;NOTES” 这首超棒的配乐，在看了剧情后，更是感受到了如日出般，绝望中诞生出新的希望的感动和热血。剧情和我很有共鸣，一群热爱某个的事物的人为自己的梦想付出努力的故事，也许主人公们并不完美，但他们都有着对梦想的热情，<del>比博燃</del></p><p>摘一个我喜欢的网易云热评：</p><blockquote><p>或许这架机器人不如屏幕中的完美，也不如屏幕中的强大，但是最后它还是动起来了，真的为了拯救这个世界而动起来了，那还有什么可遗憾的呢？还有比这令人振奋的事情吗？</p></blockquote><p>顺便我找图片的时候还看到了别人写的游记，将来有一天我也想游览各地体会风土人情！</p><p><a href="https://www.jianshu.com/p/148c5363f45c">【拜访全球最浪漫的活火山】鹿儿岛·樱岛15000字超长旅行攻略</a></p><p>说说这学期的事吧，保研基本稳定（虽然排名总体靠近估计的保研线中间），现在就是寻找方向，导师。听我们学长说计算机视觉特别卷，但还是想学……，想读视觉方向目前又担心自己上不了想去的学校，这是目前我最担心的了（自言自语中……），没有啥比赛获奖，成绩也一般，有人会要我吗……</p><p>给想去实验室的同学们一个劝告，早，一定要早去。我之前没有认识到，这学期想去实验室学习，3 周了还没找到自己应该参加什么项目。老师大部分的项目都是有一定积累的或者正在做的，去的早可以先多了解再加入，毕竟自己不在实验室，先让自己熟悉老师的方向和有哪些工作自己可以做的需要花上一定时间。</p><p>ε=(´ο｀*))) 唉，就平凡的人只能多努力了啊。</p><h1 id="去年……"><a href="#去年……" class="headerlink" title="去年……"></a>去年……</h1><p>操作系统考炸了没心情。</p><p>记下没填出来的空，也没啥用</p><ul><li>操作系统是一组：能有效组织和管理四大资源的，合理地对各类作业进行调度和控制的，方便用户使用计算机的软件。</li><li>对于用户，文件系统实现<strong>按名存取</strong></li></ul><p>嗳，就考你背诵，写不上，那你操作系统学了点啥（老师你讲了啥（笑））<strong>！！！以上是内心活动</strong></p><p>来规划一下寒假做啥</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li><p>在 2 月 23 左右开学的时候来 check</p></li><li><p>[x] 考完试平安到家（其实这仅仅是个 checkbox 的测试，写的这天没考完也没到家）</p></li></ul><h3 id="ai-x-blending-courses"><a href="#ai-x-blending-courses" class="headerlink" title="ai+x blending courses"></a>ai+x blending courses</h3><ul><li>[x] 课听完</li><li>[x] 每个 Module 整理笔记，写全英的博客</li><li>[] Live Session 整理讲的内容，尽可能反复听，最后整理一篇出来</li></ul><h3 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h3><ul><li>[] 图形学教材老师推荐的整一本看，能看多少算多少吧</li></ul><h3 id="计科"><a href="#计科" class="headerlink" title="计科"></a>计科</h3><ul><li>[] 龙书看起来，算是提前预习，至少看 3-4 章吧</li><li>[x] 自己动手写一个 64 位操作系统接着看，基础部分必须看完 + 内容整理完</li><li>[] 尝试实践自己在程序员的自我修养书中学到的编译链接的知识</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>准备夏令营</p><ul><li>[] 简历</li><li>[] 自我介绍（中+英）</li><li>[] 项目（中+英）</li></ul></li><li><p>[x] 下学期给社团新生讲课的 PPT</p></li><li>[x] 整理数学建模学到的知识</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>假期有啥想写的了（感想啥的）放这里</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;诈尸&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;2021/3/19 开学第三周，挖出来，填一下实际完成的东西。&lt;br&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
</feed>
